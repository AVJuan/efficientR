<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">

<meta name="author" content="Colin Gillespie and Robin Lovelace" />

<meta name="date" content="2016-02-16" />

  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
<title>Efficient R programming</title>

<script src="libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="libs/bootstrap-3.3.5/shim/respond.min.js"></script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
</style>
</head>

<body>

<div class="container-fluid main-container">


<!--bookdown:title:start-->
<div id="header">
<h1 class="title">Efficient R programming</h1>
<h4 class="author"><em>Colin Gillespie and Robin Lovelace</em></h4>
<h4 class="date"><em>2016-02-16</em></h4>
</div>
<!--bookdown:title:end-->

<!--bookdown:toc:start-->
<div id="TOC">
<ul>
<li><a href="#building-the-book"><span class="toc-section-number">1</span> Building the book</a><ul>
<li><a href="#dependencies-for-this-book"><span class="toc-section-number">1.1</span> Dependencies for this book</a></li>
</ul></li>
<li><a href="#introduction"><span class="toc-section-number">2</span> Introduction</a></li>
<li><a href="#efficient-set-up"><span class="toc-section-number">3</span> Efficient set-up</a><ul>
<li><a href="#operating-system"><span class="toc-section-number">3.1</span> Operating system</a><ul>
<li><a href="#operating-system-and-resource-monitoring"><span class="toc-section-number">3.1.1</span> Operating system and resource monitoring</a></li>
<li><a href="#exercises"><span class="toc-section-number">3.1.2</span> Exercises</a></li>
</ul></li>
<li><a href="#r-version"><span class="toc-section-number">3.2</span> R version</a><ul>
<li><a href="#installing-r"><span class="toc-section-number">3.2.1</span> Installing R</a></li>
<li><a href="#updating-r"><span class="toc-section-number">3.2.2</span> Updating R</a></li>
<li><a href="#installing-r-packages"><span class="toc-section-number">3.2.3</span> Installing R packages</a></li>
<li><a href="#deps"><span class="toc-section-number">3.2.4</span> Installing R packages with dependencies</a></li>
<li><a href="#updating-r-packages"><span class="toc-section-number">3.2.5</span> Updating R packages</a></li>
<li><a href="#exercises-1"><span class="toc-section-number">3.2.6</span> Exercises</a></li>
</ul></li>
<li><a href="#r-startup"><span class="toc-section-number">3.3</span> R startup</a><ul>
<li><a href="#rprofile"><span class="toc-section-number">3.3.1</span> The <code>.Rprofile</code> file</a></li>
<li><a href="#example-.rprofile-settings"><span class="toc-section-number">3.3.2</span> Example <code>.Rprofile</code> settings</a></li>
<li><a href="#renviron"><span class="toc-section-number">3.3.3</span> The <code>.Renviron</code> file</a></li>
<li><a href="#exercises-2"><span class="toc-section-number">3.3.4</span> Exercises</a></li>
</ul></li>
<li><a href="#rstudio"><span class="toc-section-number">3.4</span> RStudio</a><ul>
<li><a href="#install-rstudio"><span class="toc-section-number">3.4.1</span> Installing and updating RStudio</a></li>
<li><a href="#window-pane-layout"><span class="toc-section-number">3.4.2</span> Window pane layout</a></li>
<li><a href="#exercises-3"><span class="toc-section-number">3.4.3</span> Exercises</a></li>
<li><a href="#rstudio-options"><span class="toc-section-number">3.4.4</span> RStudio options</a></li>
<li><a href="#auto-completion"><span class="toc-section-number">3.4.5</span> Auto-completion</a></li>
<li><a href="#keyboard-shortcuts"><span class="toc-section-number">3.4.6</span> Keyboard shortcuts</a></li>
<li><a href="#object-display-and-output-table"><span class="toc-section-number">3.4.7</span> Object display and output table</a></li>
<li><a href="#project-management"><span class="toc-section-number">3.4.8</span> Project management</a></li>
<li><a href="#exercises-4"><span class="toc-section-number">3.4.9</span> Exercises</a></li>
</ul></li>
<li><a href="#blas-and-alternative-r-interpreters"><span class="toc-section-number">3.5</span> BLAS and alternative R interpreters</a><ul>
<li><a href="#revolution-r"><span class="toc-section-number">3.5.1</span> Revolution R</a></li>
<li><a href="#other-interpreters"><span class="toc-section-number">3.5.2</span> Other interpreters</a></li>
<li><a href="#useful-blasbenchmarking-resources"><span class="toc-section-number">3.5.3</span> Useful BLAS/benchmarking resources</a></li>
<li><a href="#exercises-5"><span class="toc-section-number">3.5.4</span> Exercises</a></li>
</ul></li>
</ul></li>
<li><a href="#efficient-hardware"><span class="toc-section-number">4</span> Efficient hardware</a><ul>
<li><a href="#introduction-what-is-a-byte"><span class="toc-section-number">4.1</span> Introduction: what is a byte?</a></li>
<li><a href="#ram"><span class="toc-section-number">4.2</span> Random access memory: RAM</a><ul>
<li><a href="#exercises-6"><span class="toc-section-number">4.2.1</span> Exercises</a></li>
</ul></li>
<li><a href="#hard-drives-hdd-vs-ssd"><span class="toc-section-number">4.3</span> Hard drives: HDD vs SSD</a></li>
<li><a href="#operating-systems-32-bit-or-64-bit"><span class="toc-section-number">4.4</span> Operating systems: 32-bit or 64-bit</a><ul>
<li><a href="#exercises-7"><span class="toc-section-number">4.4.1</span> Exercises</a></li>
</ul></li>
<li><a href="#central-processing-unit-cpu"><span class="toc-section-number">4.5</span> Central processing unit (CPU)</a></li>
<li><a href="#cloud-computing"><span class="toc-section-number">4.6</span> Cloud computing</a><ul>
<li><a href="#amazon-ec2"><span class="toc-section-number">4.6.1</span> Amazon EC2</a></li>
<li><a href="#exercise"><span class="toc-section-number">4.6.2</span> Exercise</a></li>
</ul></li>
</ul></li>
<li><a href="#efficient-workflow"><span class="toc-section-number">5</span> Efficient workflow</a><ul>
<li><a href="#project-planning"><span class="toc-section-number">5.1</span> Project planning</a><ul>
<li><a href="#exercises-8"><span class="toc-section-number">5.1.1</span> Exercises</a></li>
</ul></li>
<li><a href="#pkgs"><span class="toc-section-number">5.2</span> Package selection</a></li>
<li><a href="#importing-data"><span class="toc-section-number">5.3</span> Importing data</a><ul>
<li><a href="#fast-data-reading"><span class="toc-section-number">5.3.1</span> Fast data reading</a></li>
<li><a href="#preprocessing-outside-r"><span class="toc-section-number">5.3.2</span> Preprocessing outside R</a></li>
<li><a href="#working-with-databases"><span class="toc-section-number">5.3.3</span> Working with databases</a></li>
</ul></li>
<li><a href="#tidying-data-with-tidyr"><span class="toc-section-number">5.4</span> Tidying data with <strong>tidyr</strong></a></li>
<li><a href="#dplyr"><span class="toc-section-number">5.5</span> Data processing</a><ul>
<li><a href="#renaming-columns"><span class="toc-section-number">5.5.1</span> Renaming columns</a></li>
<li><a href="#filtering-rows"><span class="toc-section-number">5.5.2</span> Filtering rows</a></li>
<li><a href="#filtering-columns"><span class="toc-section-number">5.5.3</span> Filtering columns</a></li>
<li><a href="#data-aggregation"><span class="toc-section-number">5.5.4</span> Data aggregation</a></li>
</ul></li>
<li><a href="#updating-column-classes"><span class="toc-section-number">5.6</span> Updating column classes</a><ul>
<li><a href="#chaining-operations-with-dplyr"><span class="toc-section-number">5.6.1</span> Chaining operations with <strong>dplyr</strong></a></li>
<li><a href="#data.table"><span class="toc-section-number">5.6.2</span> <strong>data.table</strong></a></li>
</ul></li>
<li><a href="#publication"><span class="toc-section-number">5.7</span> Publication</a></li>
</ul></li>
<li><a href="#efficient-collaboration"><span class="toc-section-number">6</span> Efficient collaboration</a></li>
<li><a href="#efficient-programming"><span class="toc-section-number">7</span> Efficient programming</a><ul>
<li><a href="#data-types"><span class="toc-section-number">7.1</span> Data types</a><ul>
<li><a href="#vectors"><span class="toc-section-number">7.1.1</span> Vectors</a></li>
<li><a href="#factors"><span class="toc-section-number">7.1.2</span> Factors</a></li>
<li><a href="#data-frames"><span class="toc-section-number">7.1.3</span> Data frames</a></li>
<li><a href="#matrix"><span class="toc-section-number">7.1.4</span> Matrix</a></li>
<li><a href="#S3"><span class="toc-section-number">7.1.5</span> S3 objects</a></li>
<li><a href="#efficient-data-structures"><span class="toc-section-number">7.1.6</span> Efficient data structures</a></li>
</ul></li>
<li><a href="#good-programming-techniques"><span class="toc-section-number">7.2</span> Good programming techniques</a><ul>
<li><a href="#general-tips"><span class="toc-section-number">7.2.1</span> General tips</a></li>
<li><a href="#caching-variables"><span class="toc-section-number">7.2.2</span> Caching variables</a></li>
<li><a href="#function-closures"><span class="toc-section-number">7.2.3</span> Function closures</a></li>
<li><a href="#vectorised-code"><span class="toc-section-number">7.2.4</span> Vectorised code</a></li>
</ul></li>
<li><a href="#parallel-computing"><span class="toc-section-number">7.3</span> Parallel computing</a><ul>
<li><a href="#parallel-versions-of-apply-functions"><span class="toc-section-number">7.3.1</span> Parallel versions of apply functions</a></li>
<li><a href="#example-parallel-bootstraping"><span class="toc-section-number">7.3.2</span> Example: parallel bootstraping</a></li>
<li><a href="#process-forking"><span class="toc-section-number">7.3.3</span> Process forking</a></li>
</ul></li>
<li><a href="#the-byte-compiler"><span class="toc-section-number">7.4</span> The byte compiler</a><ul>
<li><a href="#example-the-mean-function"><span class="toc-section-number">7.4.1</span> Example: the mean function</a></li>
<li><a href="#compiling-code"><span class="toc-section-number">7.4.2</span> Compiling code</a></li>
</ul></li>
</ul></li>
<li><a href="#efficient-rcpp"><span class="toc-section-number">8</span> Efficient Rcpp</a></li>
<li><a href="#efficient-memory"><span class="toc-section-number">9</span> Efficient Memory</a></li>
<li><a href="#efficient-learning"><span class="toc-section-number">10</span> Efficient Learning</a></li>
</ul>
</div>
<!--bookdown:toc:end-->

<!--bookdown:body:start-->
<div id="building-the-book" class="section level1">
<h1><span class="header-section-number">1</span> Building the book</h1>
<p><img src="figures/full.png" title="" alt="" width="33%" /></p>
<p>The text and code for the forthcoming O’Reilly book: <a href="https://csgillespie.github.io/efficientR/">Efficient R programming</a>. Pull requests and general comments are welcome.</p>
<div id="dependencies-for-this-book" class="section level2">
<h2><span class="header-section-number">1.1</span> Dependencies for this book</h2>
<p>To build this book on your own system, you will need to install the following packages from CRAN:</p>
<table>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Title</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">pryr</td>
<td align="left">Tools for Computing on the Language</td>
</tr>
<tr class="even">
<td align="left">ggplot2</td>
<td align="left">An Implementation of the Grammar of Graphics</td>
</tr>
<tr class="odd">
<td align="left">fortunes</td>
<td align="left">R Fortunes</td>
</tr>
<tr class="even">
<td align="left">devtools</td>
<td align="left">Tools to Make Developing R Packages Easier</td>
</tr>
<tr class="odd">
<td align="left">drat</td>
<td align="left">Drat R Archive Template</td>
</tr>
<tr class="even">
<td align="left">rbenchmark</td>
<td align="left">Benchmarking routine for R</td>
</tr>
<tr class="odd">
<td align="left">microbenchmark</td>
<td align="left">Accurate Timing Functions</td>
</tr>
<tr class="even">
<td align="left">DiagrammeR</td>
<td align="left">Create Graph Diagrams and Flowcharts Using R</td>
</tr>
<tr class="odd">
<td align="left">tidyr</td>
<td align="left">Easily Tidy Data with <code>spread()</code> and <code>gather()</code> Functions</td>
</tr>
<tr class="even">
<td align="left">data.table</td>
<td align="left">Extension of Data.frame</td>
</tr>
<tr class="odd">
<td align="left">readr</td>
<td align="left">Read Tabular Data</td>
</tr>
<tr class="even">
<td align="left">dplyr</td>
<td align="left">A Grammar of Data Manipulation</td>
</tr>
<tr class="odd">
<td align="left">knitr</td>
<td align="left">A General-Purpose Package for Dynamic Report Generation in R</td>
</tr>
</tbody>
</table>
<p>GitHub packages to install.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">gh_pkgs =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;csgillespie/efficient_pkg&quot;</span>, <span class="st">&quot;rstudio/bookdown&quot;</span>, <span class="st">&quot;csgillespie/benchmarkme&quot;</span>)
devtools::<span class="kw">install_github</span>(gh_pkgs)</code></pre></div>
<p>Then run the command</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## For html
bookdown::<span class="kw">render_book</span>(<span class="st">&quot;index.Rmd&quot;</span>, <span class="dt">output_format =</span> bookdown::<span class="kw">html_chapters</span>())
## For pdf
bookdown::<span class="kw">render_book</span>(<span class="st">&quot;index.Rmd&quot;</span>, <span class="dt">output_format =</span> bookdown::<span class="kw">pdf_book</span>())</code></pre></div>
<!--chapter:end:index.Rmd-->
</div>
</div>
<div id="introduction" class="section level1">
<h1><span class="header-section-number">2</span> Introduction</h1>
<!-- ```{r 1_setup, include=FALSE} -->
<!-- knitr::opts_chunk$set(echo = TRUE) -->
<!-- ``` -->
<!-- Introduction 

This been removed to get the correct chapter numbers.
TODO: Reinstate with correct numbers.
-->
<!--chapter:end:01-introduction.Rmd-->
</div>
<div id="efficient-set-up" class="section level1">
<h1><span class="header-section-number">3</span> Efficient set-up</h1>
<p>An efficient computer set-up is analogous to a well-tuned vehicle: its components work in harmony, it is well-serviced, and it is fast. This chapter describes the software decisions that will enable a productive workflow. We explore how the operating system, R versions and settings, configuration of your R editor, and other settings can make your R work faster. The next chapter deals with hardware. By the end of this chapter you should understand how to optimize your computer for efficient R programming. That includes consideration of the following topics:</p>
<ul>
<li>R and the operating systems: system monitoring on Linux, Mac and Windows</li>
<li>R version: how to keep your base R installation and packages up to date</li>
<li>R start-up: how and why to adjust your <code>.Rprofile</code> and <code>.Renviron</code> files</li>
<li>RStudio: an integrated development environment (IDE) to boost your programming productivity</li>
<li>BLAS and alternative R interpreters: looks at ways to make R faster</li>
</ul>
<div id="operating-system" class="section level2">
<h2><span class="header-section-number">3.1</span> Operating system</h2>
<p>R works on all three major operating systems (OSs): Linux, Mac and Windows. R is predominantly platform-independent, meaning that it should behave in the same way on each of these platforms. This is partly facilitated by CRAN tests which ensure that R packages work in all major operating systems. There are some operating system specific quirks that may influence the choice of OS and how it is set-up for R programming in the long-term.</p>
<div id="operating-system-and-resource-monitoring" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Operating system and resource monitoring</h3>
<p>Minor differences aside,<a href="#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a> R’s computational efficiency is the same across different operating systems. This is important as it means the techniques will, in general, work equally well on different OSs. Beyond the <span class="math inline">\(32\)</span> vs <span class="math inline">\(64\)</span> bit issue (covered in the next chapter) and <em>process forking</em> (covered in Chapter 6) the main issue for many will be user friendliness and compatibility other programs used alongside R for work. Changing operating system can be a time consuming process so our advice is usually to stick to whatever OS you are most comfortable with.</p>
<p>Some packages (e.g. those that must be compiled and that depend on external libraries) are best installed at the operating system level (i.e. not using <code>install.packages</code>) on Linux systems. On Debian-based operating systems such as Ubuntu, these are named with the prefix <code>r-cran-</code> (see <a href="#deps">Section 2.4</a>).</p>
<p>Regardless of your operating system, it is good practice to track how system resources (primarily CPU and RAM use) respond when running time-consuming tasks. Alongside R profiling functions such as <code>profvis</code> (see Section <strong>XXX</strong>), system monitoring can help identify performance bottlenecks and opportunities for making tasks run faster.</p>
<p>A common use case for system monitoring of R processes is to identify how much RAM is being used and whether more is needed (covered in Chapter 3). System monitors also report the percentage of CPU resource allocated over time. On modern multi-threaded CPUs, many tasks will use only a fraction of the available CPU resource because R is by default a single-threaded program (see Chapter 6 on parallel programming). Monitoring CPU load in this context can be useful for identifying whether R is running in parallel (see Figure @ref{2-1}).</p>
<div class="figure">
<img src="figures/sysmon.png" alt="(\#fig:2-1)Output from a system monitor (`gnome-system-monitor` running on Ubuntu) showing the resources consumed by running the code presented in the second of the Exercises at the end of this section. The first increases RAM use, the second is single-threaded and the third is multi-threaded."  />
<p class="caption">
(#fig:2-1)Output from a system monitor (<code>gnome-system-monitor</code> running on Ubuntu) showing the resources consumed by running the code presented in the second of the Exercises at the end of this section. The first increases RAM use, the second is single-threaded and the third is multi-threaded.
</p>
</div>
<p>System monitoring is a complex topic that spills over into system administration and server management. Fortunately there are many tools designed to ease monitoring all major operating systems.</p>
<ul>
<li>On Linux, the shell command <code>top</code> displays key resource use figures for most distributions. <code>htop</code> and Gnome’s <strong>System Monitor</strong> (<code>gnome-system-monitor</code>, see Figure 2-1) are more refined alternatives which use command-line and graphical user interfaces respectively. A number of options such as <code>nethogs</code> monitor internet usage.</li>
<li>On Windows the <strong>Task Manager</strong> provides key information on RAM and CPU use by process. This can be started in modern Windows versions by typing <code>Ctl-Alt-Del</code> or by clicking the task bar and ‘Start Task Manager’.</li>
<li>On Mac the <strong>Activity Monitor</strong> provides similar functionality. This can be initiated form the Utilities folder in Launchpad.</li>
</ul>
</div>
<div id="exercises" class="section level3">
<h3><span class="header-section-number">3.1.2</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>What is the exact version of your computer’s operating system?</li>
<li><p>Start an activity monitor then type and execute the following code. How do the results on your system compare to those presented in Figure 2-1?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 1: Create large dataset</span>
X =<span class="st"> </span><span class="kw">data.frame</span>(<span class="kw">matrix</span>(<span class="kw">rnorm</span>(<span class="fl">1e8</span>), <span class="dt">nrow =</span> <span class="fl">1e7</span>))

<span class="co"># 2: Find the median of each column using a single core</span>
r1 =<span class="st"> </span><span class="kw">lapply</span>(X, median)

<span class="co"># 3: Find the median of each column using many cores</span>
<span class="co"># XXX: Change to function from package</span>
r2 =<span class="st"> </span>parallel::<span class="kw">mclapply</span>(X, median) <span class="co"># runs in serial on Windows</span></code></pre></div></li>
<li>What do you notice regarding CPU usage, RAM and system time, during and after each of the three operations?</li>
<li><p>Bonus question: how would the results change depending on operating system?</p></li>
</ol>
</div>
</div>
<div id="r-version" class="section level2">
<h2><span class="header-section-number">3.2</span> R version</h2>
<p>It is important to keep your R installation and packages up-to-date. This section explains how.</p>
<div id="installing-r" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Installing R</h3>
<p>The method of installing R varies for Windows, Linux and Mac.</p>
<p>On Windows, a single <code>.exe</code> file (hosted at <a href="https://cran.r-project.org/bin/windows/base/">cran.r-project.org/bin/windows/base/</a>) will install the base R package.</p>
<p>On a Mac, the latest version should be installed by downloading the <code>.pkg</code> files hosted at <a href="https://cran.r-project.org/bin/macosx/">cran.r-project.org/bin/macosx/</a>.</p>
<p>On Debian-based systems adding the CRAN repository in the format. To add the RStudio mirror for Ubuntu 14.04 (codenamed Trusty), for example, add the following line to <code>/etc/apt/sources.list</code>:</p>
<pre><code>echo &#39;deb https://cran.rstudio.com/bin/linux/ubuntu trusty`</code></pre>
<p>In the above code <code>cran.rstudio.com</code> is the mirror and <code>trusty</code> is the Ubuntu version. Then <code>r-base</code> and other <code>r-</code> packages can be installed. R also works on FreeBSD and other Unix-based systems.<a href="#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a></p>
<p>Once R is installed it should be kept up-to-date.</p>
</div>
<div id="updating-r" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Updating R</h3>
<p>R is a mature and stable language so well-written code in base R should work on most versions. However, it is important to keep your R version relatively up-to-date, because:</p>
<ul>
<li>Bug fixes are introduced in each version, making errors less likely;</li>
<li>Performance enhancements are made from one version to the next, meaning your code may run faster in later versions;</li>
<li>Many R packages only work on recent versions on R.</li>
</ul>
<p>Release notes with details on each of these issues are hosted at <a href="https://cran.r-project.org/src/base/NEWS">cran.r-project.org/src/base/NEWS</a>. R release versions have 3 components corresponding to major.minor.patch changes. Generally 2 or 3 patches are released before the next minor increment. R 3.2, for example, has consisted of 3 versions: 3.2.0, 3.2.1 and 3.2.2.</p>
<ul>
<li>On Ubuntu-based systems, new versions of R should be automatically detected through the software management system, and can be installed with <code>apt-get upgrade</code>.</li>
<li>On Mac, the latest version should be installed by the user from the <code>.pkg</code> files mentioned above.</li>
<li><p>On Windows <strong>installr</strong> package makes updating easy:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># check and install the latest R version</span>
installr::<span class="kw">updateR</span>() </code></pre></div></li>
</ul>
<p>For information about changes to expect in the next version, you can subscribe to the R’s NEWS RSS feed: <a href="http://developer.r-project.org/blosxom.cgi/R-devel/NEWS/index.rss">developer.r-project.org/blosxom.cgi/R-devel/NEWS/index.rss</a>. It’s a good way of keeping up to date.</p>
</div>
<div id="installing-r-packages" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Installing R packages</h3>
<p>Large projects may need several packages to be installed. In this case, the required packages can be installed at once. Using the example of packages for handling spatial data, this can be done quickly and concisely with the following code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pkgs =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;raster&quot;</span>, <span class="st">&quot;leaflet&quot;</span>, <span class="st">&quot;rgeos&quot;</span>) <span class="co"># package names</span>
<span class="kw">install.packages</span>(pkgs)</code></pre></div>
<p>In the above code all the required packages are installed with two not three lines, reducing typing. Note that we can now re-use the <code>pkgs</code> object to load them all:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">inst =<span class="st"> </span><span class="kw">lapply</span>(pkgs, library, <span class="dt">character.only =</span> <span class="ot">TRUE</span>) <span class="co"># load them</span></code></pre></div>
<p>In the above code <code>library(pkg[i])</code> is executed for every package stored in the text string vector. We use <code>library</code> here instead of <code>require</code> because the former produces an error if the package is not available.</p>
<p>Loading all packages at the beginning of a script is good practice as it ensures all dependencies have been installed <em>before</em> time is spent executing code. Storing package names in a character vector object such as <code>pkgs</code> is also useful because it allows us to refer back to them again and again. To provide another example, we can update only the packages named in <code>pkgs</code> with the following command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">update.packages</span>(<span class="dt">oldPkgs =</span> pkgs)</code></pre></div>
</div>
<div id="deps" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Installing R packages with dependencies</h3>
<p>Some packages have external dependencies (i.e. they call libraries outside R). On Unix-like systems, these are best installed onto the operating system, bypassing <code>install.packages</code>. This will ensure the necessary dependencies are installed and setup correctly alongside the R package. On Debian-based distributions such as Ubuntu, for example, packages with names starting with <code>r-cran-</code> can be search for and installed as follows (see <a href="https://cran.r-project.org/bin/linux/ubuntu/">cran.r-project.org/bin/linux/ubuntu/</a> for a list of these):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">apt-cache</span> search r-cran- <span class="co"># search for available cran Debian packages</span>
<span class="kw">sudo</span> apt-get-install r-cran-rgdal <span class="co"># install the rgdal package (with dependencies)</span></code></pre></div>
<p>On Windows the <strong>installr</strong> package helps manage and update R packages with system-level dependencies. For example the <strong>Rtools</strong> package for compiling C/C++ code on Window can be installed with the following command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">installr::<span class="kw">install.rtools</span>() </code></pre></div>
</div>
<div id="updating-r-packages" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Updating R packages</h3>
<p>An efficient R set-up will contain up-to-date packages. This can be done <em>for all packages</em> with:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">update.packages</span>() <span class="co"># update installed CRAN packages</span></code></pre></div>
<p>The default for this function is for the <code>ask</code> argument to be set to <code>TRUE</code>, giving control over what is downloaded onto your system.<a href="#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a> This is a good thing: updating dozens of large packages can consume a large proportion of available system resources and much time!</p>
<p>An even more interactive method for updating packages in R is provided by RStudio via Tools &gt; Check for Package Updates. Many such time saving tricks are enabled by RStudio, as described in <a href="#install-rstudio">a subsequent section</a>. Next (after the exercises) we take a look at how to configure R using start-up files.</p>
</div>
<div id="exercises-1" class="section level3">
<h3><span class="header-section-number">3.2.6</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>What version of R are you using? Is it the most up-to-date?</li>
<li>Do any of your packages need updating?</li>
</ol>
</div>
</div>
<div id="r-startup" class="section level2">
<h2><span class="header-section-number">3.3</span> R startup</h2>
<p>Every time R starts, a number of files are read, in a particular order. The contents of these files determine how R performs for the duration of the session. Note that these files should only be changed with caution, as they may make your R version behave differently to other R installations. This could reduce the reproducibility of your code.</p>
<p>Files in three folders are important in this process:</p>
<ul>
<li><p><code>R_HOME</code>, the directory in which R is installed. The <code>etc</code> sub-directory can contain start-up files read early on in the start-up process. Find out where your <code>R_HOME</code> is with the <code>R.home()</code> command.</p></li>
<li><p><code>HOME</code>, the user’s home directory. Typically this is <code>/home/username</code> on Unix machines or <code>C:\Users\username</code> on Windows (since Windows 7). Ask R where your home directory with, <code>path.expand(&quot;~&quot;)</code> (note the use of the Unix-like tilde to represent the home directory).</p></li>
<li><p>R’s current working directory. This is reported by <code>getwd()</code>.</p></li>
</ul>
<p>It is important to know the location of the <code>.Rprofile</code> and <code>.Renviron</code> set-up files that are being used out of these three options. R only uses one <code>.Rprofile</code> and one <code>.Renviron</code> in any session: if you have a <code>.Rprofile</code> file in your current project, R will ignore <code>.Rprofile</code> in <code>R_HOME</code> and <code>HOME</code>. Likewise, <code>.Rprofile</code> in <code>HOME</code> overrides <code>.Rprofile</code> in <code>R_HOME</code>. The same applies to <code>.Renviron</code>: you should remember that adding project specific environment variables with <code>.Renviron</code> will de-activate other <code>.Renviron</code> files.</p>
<p>To create a project-specific start-up script, simply create a <code>.Rprofile</code> file in the project’s root directory and start adding R code, e.g. via <code>file.edit(&quot;.Rprofile&quot;)</code>. Remember that this will make <code>.Rprofile</code> in the home directory be ignored. The following commands will open your <code>.Rprofile</code> from within an R editor:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">file.edit</span>(<span class="kw">file.path</span>(<span class="st">&quot;~&quot;</span>, <span class="st">&quot;.Rprofile&quot;</span>)) <span class="co"># edit .Rprofile in HOME</span>
<span class="kw">file.edit</span>(<span class="st">&quot;.Rprofile&quot;</span>) <span class="co"># edit project specific .Rprofile</span></code></pre></div>
<p>Note that editing the <code>.Renviron</code> file in the same locations will have the same effect. The following code will create a user specific <code>.Renviron</code> file (where API keys and other cross-project environment variables can be stored), without overwriting any existing file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">user_renviron =<span class="st"> </span><span class="kw">path.expand</span>(<span class="kw">file.path</span>(<span class="st">&quot;~&quot;</span>, <span class="st">&quot;.Renviron&quot;</span>))
if(!<span class="kw">file.exists</span>(user_renviron)) <span class="co"># check to see if the file already exists</span>
  <span class="kw">file.create</span>(user_renviron)
<span class="kw">file.edit</span>(user_renviron) <span class="co"># open with another text editor if this fails</span></code></pre></div>
<p>The location, contents and uses of each is outlined in more detail below.</p>
<div id="rprofile" class="section level3">
<h3><span class="header-section-number">3.3.1</span> The <code>.Rprofile</code> file</h3>
<p>By default R looks for and runs <code>.Rprofile</code> files in the three locations described above, in a specific order. <code>.Rprofile</code> files are simply R scripts that run each time R runs and they can be found within <code>R_HOME</code>, <code>HOME</code> and the project’s home directory, found with <code>getwd()</code>. To check if you have a site-wide <code>.Rprofile</code>, which will run for all users on start-up, run:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">site_path =<span class="st"> </span><span class="kw">R.home</span>(<span class="dt">component =</span> <span class="st">&quot;home&quot;</span>)
fname =<span class="st"> </span><span class="kw">file.path</span>(site_path, <span class="st">&quot;etc&quot;</span>, <span class="st">&quot;Rprofile.site&quot;</span>)
<span class="kw">file.exists</span>(fname)</code></pre></div>
<p>The above code checks for the presence of <code>Rprofile.site</code> in that directory. As outlined above, the <code>.Rprofile</code> located in your home directory is user-specific. Again, we can test whether this file exists using</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">file.exists</span>(<span class="st">&quot;~/.Rprofile&quot;</span>)</code></pre></div>
<p>We can use R to create and edit <code>.Rprofile</code> (warning: do not overwrite your previous <code>.Rprofile</code> - we suggest you try project-specific <code>.Rprofile</code> first):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(!<span class="kw">file.exists</span>(<span class="st">&quot;~/.Rprofile&quot;</span>)) <span class="co"># only create if not already there</span>
  <span class="kw">file.create</span>(<span class="st">&quot;~/.Rprofile&quot;</span>)    <span class="co"># (don&#39;t overwrite it)</span>
<span class="kw">file.edit</span>(<span class="st">&quot;~/.Rprofile&quot;</span>)</code></pre></div>
</div>
<div id="example-.rprofile-settings" class="section level3">
<h3><span class="header-section-number">3.3.2</span> Example <code>.Rprofile</code> settings</h3>
<p>An <code>.Rprofile</code> file is just an R script that is run at start-up. The examples at the bottom of the <code>.Rprofile</code> help file</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">help</span>(<span class="st">&quot;Rprofile&quot;</span>)</code></pre></div>
<p>give clues as to the types of things we could place in our profile.</p>
<div id="setting-options" class="section level4">
<h4><span class="header-section-number">3.3.2.1</span> Setting options</h4>
<p>The function <code>options</code> is a list that contains a number of default options. See <code>help(&quot;options&quot;)</code> or simply type <code>options()</code> to get an idea of what we can configure. In my <code>.Rprofile</code> file, we have the line</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">prompt=</span><span class="st">&quot;R&gt; &quot;</span>, <span class="dt">digits=</span><span class="dv">4</span>, <span class="dt">show.signif.stars=</span><span class="ot">FALSE</span>)</code></pre></div>
<p>This changes three features.</p>
<ul>
<li>The R prompt, from the boring <code>&gt;</code> to the exciting <code>R&gt;</code>.</li>
<li>The number of digits displayed.</li>
<li>Removing the stars after significant <span class="math inline">\(p\)</span>-values.</li>
</ul>
<p>Typically we want to avoid adding options to the start-up file that make our code non-portable. For example, adding</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">options</span>(<span class="dt">stringsAsFactors=</span><span class="ot">FALSE</span>)</code></pre></div>
<p>to your start-up script has knock-on effects for <code>read.table</code> and related functions including <code>read.csv</code>, making them convert text strings into characters rather than into factors as is default. This may be useful for you, but it is dangerous as it may make your code less portable.</p>
</div>
<div id="setting-the-cran-mirror" class="section level4">
<h4><span class="header-section-number">3.3.2.2</span> Setting the CRAN mirror</h4>
<p>To avoid setting the CRAN mirror each time you run <code>install.packages</code> you can permanently set the mirror in your <code>.Rprofile</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## local creates a new, empty environment
## This avoids polluting the global environment with
## the object r
<span class="kw">local</span>({
  r =<span class="st"> </span><span class="kw">getOption</span>(<span class="st">&quot;repos&quot;</span>)             
  r[<span class="st">&quot;CRAN&quot;</span>] =<span class="st"> &quot;https://cran.rstudio.com/&quot;</span>
  <span class="kw">options</span>(<span class="dt">repos =</span> r)
})</code></pre></div>
<p>The RStudio mirror is a virtual machine run by Amazon’s EC2 service, and it syncs with the main CRAN mirror in Austria once per day. Since RStudio is using Amazon’s CloudFront, the repository is automatically distributed around the world, so no matter where you are in the world, the data doesn’t need to travel very far, and is therefore fast to download.</p>
</div>
<div id="the-fortunes-package" class="section level4">
<h4><span class="header-section-number">3.3.2.3</span> The <strong>fortunes</strong> package</h4>
<p>This section illustrate what <code>.Rprofile</code> does with reference to a package that was developed for fun. The code below could easily be altered to automatically connect to a database, or ensure that the latest packages have been downloaded.</p>
<p>The <strong>fortunes</strong> package contains a number of memorable quotes that the community has collected over many years, called R fortunes. Each fortune has a number. To get fortune number <span class="math inline">\(50\)</span>, for example, enter</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fortunes::<span class="kw">fortune</span>(<span class="dv">50</span>)</code></pre></div>
<p>It is easy to make R print out one of these nuggets of truth each time you start a session, by adding the following to <code>~/.Rprofile</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">if(<span class="kw">interactive</span>()) 
  <span class="kw">try</span>(fortunes::<span class="kw">fortune</span>(), <span class="dt">silent=</span><span class="ot">TRUE</span>)</code></pre></div>
<p>The <code>interactive</code> function tests whether R is being used interactively in a terminal. The <code>fortune</code> function is called within <code>try</code>. If the <strong>fortunes</strong> package is not available, we avoid raising an error and move on. By using <code>::</code> we avoid adding the <strong>fortunes</strong> package to our list of attached packages..</p>
<p>The function <code>.Last</code>, if it exists in the <code>.Rprofile</code>, is always run at the end of the session. We can use it to install the <strong>fortunes</strong> package if needed. To load the package, we use <code>require</code>, since if the package isn’t installed, the <code>require</code> function returns <code>FALSE</code> and raises a warning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.Last =<span class="st"> </span>function() {
  cond =<span class="st"> </span><span class="kw">suppressWarnings</span>(!<span class="kw">require</span>(fortunes, <span class="dt">quietly=</span><span class="ot">TRUE</span>))
  if(cond) 
    <span class="kw">try</span>(<span class="kw">install.packages</span>(<span class="st">&quot;fortunes&quot;</span>), <span class="dt">silent=</span><span class="ot">TRUE</span>)
  <span class="kw">message</span>(<span class="st">&quot;Goodbye at &quot;</span>, <span class="kw">date</span>(), <span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>)
}</code></pre></div>
</div>
<div id="useful-functions" class="section level4">
<h4><span class="header-section-number">3.3.2.4</span> Useful functions</h4>
<p>You can also load useful functions in <code>.Rprofile</code>. For example, we could load the following two functions for examining data frames:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## ht == headtail
ht =<span class="st"> </span>function(d, <span class="dt">n=</span><span class="dv">6</span>) <span class="kw">rbind</span>(<span class="kw">head</span>(d, n), <span class="kw">tail</span>(d, n))
  
## Show the first 5 rows &amp; first 5 columns of a data frame
hh =<span class="st"> </span>function(d) d[<span class="dv">1</span>:<span class="dv">5</span>, <span class="dv">1</span>:<span class="dv">5</span>]</code></pre></div>
<p>and a function for setting a nice plotting window:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">setnicepar =<span class="st"> </span>function(<span class="dt">mar =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>), <span class="dt">mgp =</span> <span class="kw">c</span>(<span class="dv">2</span>, <span class="fl">0.4</span>, <span class="dv">0</span>), 
                      <span class="dt">tck =</span> -.<span class="dv">01</span>, <span class="dt">cex.axis =</span> <span class="fl">0.9</span>, 
                      <span class="dt">las =</span> <span class="dv">1</span>, <span class="dt">mfrow =</span> <span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), ...) {
    <span class="kw">par</span>(<span class="dt">mar =</span> mar, <span class="dt">mgp =</span> mgp, <span class="dt">tck =</span> tck,
        <span class="dt">cex.axis =</span> cex.axis, <span class="dt">las =</span> las, 
        <span class="dt">mfrow =</span> mfrow, ...)
}</code></pre></div>
<p>Note that these functions are for personal use and are unlikely to interfere with code from other people. For this reason even if you use a certain package every day, we don’t recommend loading it in your <code>.Rprofile</code>. Also beware the dangers of loading many functions by default: it may make your code less portable. Another downside of putting functions in your <code>.Rprofile</code> is that it can clutter-up your work space: when you run the <code>ls()</code> command, your <code>.Rprofile</code> functions will appear. Also if you run <code>rm(list=ls())</code>, your functions will be deleted.</p>
<p>One neat trick to overcome this issue is to use hidden objects and environments. When an object name starts with <code>.</code>, by default it doesn’t appear in the output of the <code>ls()</code> function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.obj =<span class="st"> </span><span class="dv">1</span>
<span class="st">&quot;.obj&quot;</span> %in%<span class="st"> </span><span class="kw">ls</span>()</code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>This concept also works with environments. In the <code>.Rprofile</code> file we can create a <em>hidden</em> environment</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.env =<span class="st"> </span><span class="kw">new.env</span>()</code></pre></div>
<p>and then add functions to this environment</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.env$ht =<span class="st"> </span>function(d, <span class="dt">n =</span> <span class="dv">6</span>) <span class="kw">rbind</span>(<span class="kw">head</span>(d, n), <span class="kw">tail</span>(d, n))</code></pre></div>
<p>At the end of the <code>.Rprofile</code> file, we use <code>attach</code>, which makes it possible to refer to objects in the environment by their names alone.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(.env)</code></pre></div>
<!--
\sidenote{I also have a function that shows the size of
  objects in my R session (\url{http://stackoverflow.com/q/1358003/203420}).}-->
</div>
</div>
<div id="renviron" class="section level3">
<h3><span class="header-section-number">3.3.3</span> The <code>.Renviron</code> file</h3>
<p>The <code>.Renviron</code> file is used to store system variables. It follows a similar start up routine to the <code>.Rprofile</code> file: R first looks for a global <code>.Renviron</code> file, then for local versions. A typical use of the <code>.Renviron</code> file is to specify the <code>R_LIBS</code> path</p>
<pre><code>## Linux
R_LIBS=~/R/library

## Windows
R_LIBS=C:/R/library</code></pre>
<p>This variable points to a directory where R packages will be installed. When <code>install.packages</code> is called, new packages will be stored in <code>R_LIBS</code>.</p>
<p>Another common use of <code>.Renviron</code> is to store API keys that will be available from one session to another.<a href="#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a> The following line in <code>.Renviron</code>, for example, sets the <code>ZEIT_KEY</code> environment variable which is used in the package <a href="https://cran.r-project.org/web/packages/diezeit/">diezeit</a> package:</p>
<pre><code>ZEIT_KEY=PUT_YOUR_KEY_HERE</code></pre>
<p>You will need to sign-in and start a new R session for the environment variable (accessed by <code>Sys.getenv</code>) to be visible. To test if the example API key has been successfully added as an environment variable, run the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">Sys.getenv</span>(<span class="st">&quot;ZEIT_KEY&quot;</span>)</code></pre></div>
<p>Use of the <code>.Renviron</code> file for storing settings such as library paths and API keys is efficient because it reduces the need to update your settings for every R session. Furthermore, the same <code>.Renviron</code> file will work across different platforms so keep it stored safely.</p>
</div>
<div id="exercises-2" class="section level3">
<h3><span class="header-section-number">3.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>What are the three locations where they are stored? Where are these locations on your computer?</li>
<li>For each location, does a <code>.Rprofile</code> or <code>.Renviron</code> file exist?</li>
<li>Create a <code>.Rprofile</code> file in your current working directory that prints the message <code>Happy efficient R programming</code> each time you start R at this location.</li>
</ol>
</div>
</div>
<div id="rstudio" class="section level2">
<h2><span class="header-section-number">3.4</span> RStudio</h2>
<p>RStudio is an Integrated Development Environment (IDE) for R. It makes life easy for R users and developers with its intuitive and flexible interface. RStudio encourages good programming practice. Through its wide range of features RStudio can help make you a more efficient and productive R programmer, for example by reducing the amount of time spent remembering and typing function names thanks to intelligent autocompletion. Some of the most important features of RStudio include:</p>
<ul>
<li>Flexible window pane layouts to optimise use of screen space and enable fast interactive visual feed-back.</li>
<li>Intelligent auto-completion of function names, packages and R objects.</li>
<li>A wide range of keyboard shortcuts.</li>
<li>Visual display of objects, including a searchable data display table.</li>
<li>Real-time code checking and error detection.</li>
<li>Menus to install and update packages.</li>
<li>Project management and integration with version control.</li>
</ul>
<p>The above list of features should make it clear that a well set-up IDE can be as important as a well set-up R installation for becoming an efficient R programmer.<a href="#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a> As with R itself, the best way to learn about RStudio is by using it. It is therefore worth reading through this section in parallel with using RStudio to boost your productivity.</p>
<div id="install-rstudio" class="section level3">
<h3><span class="header-section-number">3.4.1</span> Installing and updating RStudio</h3>
<p>RStudio can be installed from the RStudio website <a href="https://www.rstudio.com/products/rstudio/download/">rstudio.com</a> and is available for all major operating systems. Updating RStudio is simple: click on <code>Help &gt; Check for Updates</code> in the menu. For fast and efficient work keyboard shortcuts should be used wherever possible, reducing the reliance on the mouse. RStudio has many keyboard shortcuts that will help with this. To get into good habits early, try accessing the RStudio Update interface without touching the mouse. On Linux and Windows dropdown menus are activated with the <code>Alt</code> button, so the menu item can be found with:</p>
<pre><code>Alt+H U</code></pre>
<p>On Mac it works differently. <code>Cmd+?</code> should activate a search across menu items, allowing the same operation can be achieved with:</p>
<pre><code>Cmd+? update</code></pre>
<p><strong>Note:</strong> in RStudio the keyboard shortcuts differ between Linux and Windows versions on one hand and Mac on the other. In this section we generally only use the Windows/Linux shortcut keys for brevity. The Mac equivalent is usually found by simply replacing <code>Ctl</code> and <code>Alt</code> with the Mac-specific <code>Cmd</code> button.</p>
</div>
<div id="window-pane-layout" class="section level3">
<h3><span class="header-section-number">3.4.2</span> Window pane layout</h3>
<p>RStudio has four main window ‘panes’ (see Figure @ref(fig:rstudio)), each of which serves a range of purposes:</p>
<ul>
<li><p>The <strong>Source pane</strong>, for editing, saving, and dispatching R code to the console (top left). Note that this pane does not exist by default when you start RStudio: it appears when you open an R script, e.g. via File -&gt; New File -&gt; R Script. A common task in this pane is to send code on the current line to the console, via <code>Ctl-Enter</code> (or <code>Cmd-Enter</code> on Mac).</p></li>
<li><p>The <strong>Console pane</strong>. Any code entered here is processed by R, line by line. This pane is ideal for interactively testing ideas before saving the final results in the Source pane above.</p></li>
<li><p>The <strong>Environment pane</strong> (top right) contains information about the current objects loaded in the workspace including their class, dimension (if they are a data frame) and name. This pane also contains tabbed sub-panes with a searchable history that was dispatched to the console and (if applicable to the project) Build and Git options.</p></li>
<li><p>The <strong>Files pane</strong> (bottom right) contains a simple file browser, a Plots tab, Help and Package tabs and a Viewer for visualising interactive R output such as those produced by the leaflet package and HTML ‘widgets’.</p></li>
</ul>
<div class="figure">
<img src="figures/rstudio.png" alt="(\#fig:rstudio)RStudio Panels"  />
<p class="caption">
(#fig:rstudio)RStudio Panels
</p>
</div>
<p>Using each of the panels effectively and navigating between them quickly is a skill that will develop over time, and will only improve with practice.</p>
</div>
<div id="exercises-3" class="section level3">
<h3><span class="header-section-number">3.4.3</span> Exercises</h3>
<p>You are developing a project to visualise data. Test out the multi-panel RStudio workflow by following the steps below:</p>
<ol style="list-style-type: decimal">
<li><p>Create a new folder for the input data using the <strong>Files pane</strong>.</p></li>
<li>Type in <code>downl</code> in the <strong>Source pane</strong> and hit <code>Enter</code> to make the function <code>download.file()</code> autocomplete. Then type <code>&quot;</code>, which will autocomplete to <code>&quot;&quot;</code>, paste the URL of a file to download (e.g. <code>https://www.census.gov/2010census/csv/pop_change.csv</code>) and a file name (e.g. <code>pop_change.csv</code>).</li>
<li><p>Execute the full command with <code>Ctl-Enter</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">download.file</span>(<span class="st">&quot;https://www.census.gov/2010census/csv/pop_change.csv&quot;</span>,
              <span class="st">&quot;data/pop_change.csv&quot;</span>)</code></pre></div></li>
<li><p>Write and execute a command to read-in the data, such as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pop_change =<span class="st"> </span><span class="kw">read.csv</span>(<span class="st">&quot;data/pop_change.csv&quot;</span>, <span class="dt">skip =</span> <span class="dv">2</span>)</code></pre></div></li>
<li><p>Use the <strong>Environment pane</strong> to click on the data object <code>pop_change</code>. Note that this runs the command <code>View(pop_change)</code>, which launches an interactive data explore pane in the top left panel (see Figure 2-3).</p>
<div class="figure">
<img src="figures/View.png" alt="(\#fig:2-3)The data viewing tab in RStudio."  />
<p class="caption">
(#fig:2-3)The data viewing tab in RStudio.
</p>
</div></li>
<li><p>Use the <strong>Console</strong> to test different plot commands to visualise the data, saving the code you want to keep back into the <strong>Source pane</strong>, as <code>pop_change.R</code>.</p></li>
<li><p>Use the <strong>Plots tab</strong> in the Files pane to scroll through past plots. Save the best using the Export dropdown button.</p></li>
</ol>
<p>The above example shows understanding of these panes and how to use them interactively can help with the speed and productivity of you R programming. Further, there are a number of RStudio settings that can help ensure that it works for your needs.</p>
</div>
<div id="rstudio-options" class="section level3">
<h3><span class="header-section-number">3.4.4</span> RStudio options</h3>
<p>A range of <code>Project Options</code> and <code>Global Options</code> are available in RStudio from the <code>Tools</code> menu (accessible in Linux and Windows from the keyboard via <code>Alt+T</code>). Most of these are self-explanatory but it is worth mentioning a few that can boost your programming efficiency:</p>
<ul>
<li><p>GIT/SVN project settings allow RStudio to provide a graphical interface to your version control system, described in Chapter XX.</p></li>
<li><p>R version settings allow RStudio to ‘point’ to different R versions/interpreters, which may be faster for some projects.</p></li>
<li><p><code>Restore .RData</code>: Unticking this default preventing loading previously creating R objects. This will make starting R quicker and also reduce the change of getting bugs due to previously created objects.</p></li>
<li><p>Code editing options can make RStudio adapt to your coding style, for example, by preventing the autocompletion of braces, which some experienced programmers may find annoying. Enabling <code>Vim mode</code> makes RStudio act as a (partial) Vim emulator.</p></li>
<li><p>Diagnostic settings can make RStudio more efficient by adding additional diagnostics or by removing diagnostics if they are slowing down your work. This may be an issue for people using RStudio to analyse large datasets on older low-spec computers.</p></li>
<li><p>Appearance: if you are struggling to see the source code, changing the default font size may make you a more efficient programmer by reducing the time overheads associated with squinting at the screen. Other options in this area relate more to aesthetics, which are also important because feeling comfortable in your programming environment can boost productivity.</p></li>
</ul>
</div>
<div id="auto-completion" class="section level3">
<h3><span class="header-section-number">3.4.5</span> Auto-completion</h3>
<p>R provides some basic autocompletion functionality. Typing the beginning of a function name, for example <code>rn</code> (short for <code>rnorm()</code>), and hitting <code>Tab</code> will result in the full function names associated with this text string being printed. In this case two options would be displayed: <code>rnbinom</code> and <code>rnorm</code>, providing a useful reminder to the user about what is available. The same applies to file names enclosed in quote marks: typing <code>te</code> in the console in a project which contains a file called <code>test.R</code> should result in the full name <code>&quot;test.R&quot;</code> being auto-completed. RStudio builds on this functionality and takes it to a new level.</p>
<p>Instead of only auto completing options when <code>Tab</code> is pressed, RStudio auto completes them at any point. Building on the previous example, RStudio’s autocompletion triggers when the first three characters are typed: <code>rno</code>. The same functionality works when only the first characters are typed, followed by <code>Tab</code>: automatic auto-completion does not replace <code>Tab</code> autocompletion but supplements it. Note that in RStudio two more options are provided to the user after entering <code>rn Tab</code> compared with entering the same text into base R’s console described in the previous paragraph: <code>RNGkind</code> and <code>RNGversion</code>. This illustrates that RStudio’s autocompletion functionality is not case sensitive in the same way that R is. This is a good thing because R has no consistent function name style!</p>
<p>RStudio also has more intelligent auto-completion of objects and file names than R’s built-in command line. To test this functionality, try typing <code>US</code>, followed by the Tab key. After pressing down until <code>USArrests</code> is selected, press Enter so it autocompletes. Finally, typing <code>$</code> should leave the following text on the screen and the four columns should be shown in a drop-down box, ready for you to select the variable of interest with the down arrow.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">USArrests$<span class="st"> </span><span class="co"># a dropdown menu of columns should appear in RStudio</span></code></pre></div>
<p>To take a more complex example, variable names stored in the <code>data</code> slot of the class <code>SpatialPolygonsDataFrame</code> (a class defined by the foundational spatial package sp) are referred to in the long form <code>spdf@data$varname</code>.<a href="#fn6" class="footnoteRef" id="fnref6"><sup>6</sup></a> In this case <code>spdf</code> is the object name, <code>data</code> is the slot and <code>varname</code> is the variable name. RStudio makes such <code>S4</code> objects easier to use by enabling autocompletion of the short form <code>spdf$varname</code>. Another example is RStudio’s ability to find files hidden away in sub-folders. Typing <code>&quot;te</code> will find <code>test.R</code> even if it is located in a sub-folder such as <code>R/test.R</code>. There are a number of other clever auto-completion tricks that can boost R’s productivity when using RStudio which are best found by experimenting and hitting <code>Tab</code> frequently during your R programming work.</p>
</div>
<div id="keyboard-shortcuts" class="section level3">
<h3><span class="header-section-number">3.4.6</span> Keyboard shortcuts</h3>
<p>RStudio has many useful shortcuts that can help make your programming more efficient by reducing the need to reach for the mouse and point and click your way around code and RStudio. These can be viewed by using a little known but extremely useful keyboard shortcut:</p>
<pre><code>Alt+Shift+K</code></pre>
<p>This will display the default shortcuts in RStudio. It is worth spending time identifying which of these could be useful in your work and practising interacting with RStudio rapidly with minimal reliance on the mouse. Some more <a href="http://stronginstruments.com/2014/11/26/rstudio-shortcuts-windows-for-cleaner-and-faster-coding/">useful</a> shortcuts are listed below. There are many more gems to find that could boost your R writing productivity:</p>
<ul>
<li><code>Ctl+Z/Shift+Z</code>: Undo/Redo.</li>
<li><code>Ctl+Enter</code>: Execute the current line or code selection in the Source pane.</li>
<li><code>Ctl+Alt+R</code>: Execute all the R code in the currently open file in the Source pane.</li>
<li><code>Ctl+Left/Right</code>: Navigate code quickly, word by word.</li>
<li><code>Home/End</code>: Navigate to the beginning/end of the current line.</li>
<li><code>Alt+Shift+Up/Down</code>: Duplicate the current line up or down.</li>
<li><code>Ctl+D</code>: Delete the current line.</li>
</ul>
</div>
<div id="object-display-and-output-table" class="section level3">
<h3><span class="header-section-number">3.4.7</span> Object display and output table</h3>
<p>It is useful to know what is in your current R environment. This information can be revealed with <code>ls()</code>, but this function only provides object names. RStudio provides an efficient mechanism to show currently loaded objects, and their details, in real-time: the Environment tab in the top right corner. It makes sense to keep an eye on which objects are loaded and to delete objects that are no longer useful. Doing so will minimise the probability of confusion in your workflow (e.g. by using the wrong version of an object) and reduce the amount of RAM R needs. The details provided in the Environment tab include the object’s dimension and some additional details depending on the object’s class (e.g. size in MB for large datasets).</p>
<p>A very useful feature of RStudio is its advanced viewing functionality. This is triggered either by executing <code>View(object)</code> or by double clicking on the object name in the Environment tab. Although you cannot edit data in the Viewer (this should be considered a good thing from a data integrity perspective), recent versions of RStudio provide an efficient search mechanism to rapidly filter and view the records that are of most interest (see Figure 2-3 above).</p>
</div>
<div id="project-management" class="section level3">
<h3><span class="header-section-number">3.4.8</span> Project management</h3>
<p>In the far top-right of RStudio there is a diminutive drop-down menu illustrated with R inside a transparent box. This menu may be small and simple, but it is hugely efficient in terms of organising large, complex and long-term projects.</p>
<p>The idea of RStudio projects is that the bulk of R programming work is part of a wider task, which will likely consist of input data, R code, graphical and numerical outputs and documents describing the work. It is possible to scatter each of these elements at random across your hard-discs but this is not recommended. Instead, the concept of projects encourages reproducible working, such that anyone who opens the particular project folder that you are working from should be able to repeat your analyses and replicate your results.</p>
<p>It is therefore <em>highly recommended</em> that you use projects to organise your work. It could save hours in the long-run. Organizing data, code and outputs also makes sense from a portability perspective: if you copy the folder (e.g. via GitHub) your can work on it from any computer without worrying about having the right files on your current machine. These tasks are implemented using RStudio’s simple project system, in which the following things happen each time you open an existing project:</p>
<ul>
<li><p>The working directory automatically switches to the project’s folder. This enables data and script files to be referred to using relative file paths, which are much shorter than absolute file paths. This means that switching directory using <code>setwd()</code>, a common source of error for R users, is rarely if ever needed.</p></li>
<li><p>The last previously open file is loaded into the Source pane. The history of R commands executed in previous sessions is also loaded into the History tab. This assists with continuity between one session and the next.</p></li>
<li><p>The <code>File</code> tab displays the associated files and folders in the project, allowing you to quickly find your previous work.</p></li>
<li><p>Any settings associated with the project, such as Git settings, are loaded. This assists with collaboration and project-specific set-up.</p></li>
</ul>
<p>Each project is different but most contain input data, R code and outputs. To keep things tidy, we recommend a sub-directory structure resembling the following:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">project/</span>
  <span class="kw">-</span> README.rmd <span class="co"># Project description</span>
  <span class="kw">-</span> set-up.R  <span class="co"># Required packages</span>
  <span class="kw">-</span> R/ <span class="co"># For R code</span>
  <span class="kw">-</span> input <span class="co"># Data files</span>
  <span class="kw">-</span> graphics/
  <span class="kw">-</span> output/ <span class="co"># Results</span></code></pre></div>
<p>Proper use of projects ensures that all R source files are neatly stashed in one folder with a meaningful structure. This way data and documentation can be found where one would expect them. Under this system figures and project outputs are ‘first class citizens’ within the project’s design, each with their own folder.</p>
<p>Another approach to project management is to treat projects as R packages. Creating R packages is easier than ever before, with tools such as <strong>devtools</strong> for managing R’s quirks and making the process user friendly. If you use GitHub, the advantage of this approach is that anyone should be able to reproduce your working using <code>devtools::install_github(&quot;username/projectname&quot;)</code>, although the administrative overheads of creating an entire package for each small project will outweigh the benefits for many.</p>
<p>Note that a <code>set-up.R</code> or even a <code>.Rprofile</code> file in the project’s root directory enable project-specific settings to be loaded each time people work on the project. As described in the previous section, <code>.Rprofile</code> can be used to tweak how R works at start-up. It is also a portable way to manage R’s configuration on a project-by-project basis.</p>
</div>
<div id="exercises-4" class="section level3">
<h3><span class="header-section-number">3.4.9</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Try modifying the look and appearance of your RStudio setup.</p></li>
<li><p>What is the keyboard shortcut to show the other shortcut? (Hint: it begins with <code>Alt+Shift</code>.)</p></li>
<li><p>Try as many of the shortcuts revealed by the previous step as you like. Write down the ones that you think will save you time, perhaps on a post-it note to go on your computer.</p></li>
</ol>
</div>
</div>
<div id="blas-and-alternative-r-interpreters" class="section level2">
<h2><span class="header-section-number">3.5</span> BLAS and alternative R interpreters</h2>
<p>In this section we cover a few system-level options available to speed-up R’s performance. Note that for many applications stability rather than speed is a priority, so these should only be considered if a) you have exhausted options for writing your R code more efficiently and b) you are confident tweaking system-level settings. This should therefore be seen as an advanced section: if you are not interested in speeding-up base R, feel free to skip to the next section of hardware.</p>
<p>Many statistical algorithms manipulate matrices. R uses the Basic Linear Algebra System (BLAS) framework for linear algebra operations. Whenever we carry out a matrix operation, such as transpose or finding the inverse, we use the underlying BLAS library. By switching to a different BLAS library, it may be possible to speed-up your R code. Changing your BLAS library is straightforward if you are using Linux, but can be tricky for Windows users.</p>
<p>The two open source alternative BLAS libraries are <a href="http://math-atlas.sourceforge.net/">ATLAS</a> and <a href="https://github.com/xianyi/OpenBLAS">OpenBLAS</a>. The <a href="https://software.intel.com/en-us/intel-mkl">Intel MKL</a> is another implementation, designed for Intel processors by Intel and used in Revolution R (described in the next section) but it requires licensing fees. The MKL library is provided with the Revolution analytics system. Depending on your application, by switching you BLAS library, linear algebra operations can run several times faster than with the base BLAS routines.</p>
<!--
 Currently only works for linux.
 
To find out what BLAS library you are using on Linux the following function, from the [benchmarkme](https://github.com/csgillespie/benchmarkme) package can be used:


```r
# devtools::install_github("csgillespie/benchmarkme")
benchmarkme::get_linear_algebra()
```
-->
<div id="revolution-r" class="section level3">
<h3><span class="header-section-number">3.5.1</span> Revolution R</h3>
<p>Revolution R is the main software product offered by Revolution Analytics. It is “100%” compatible with R“, supporting all available packages through the MRAN package repository. Revolution R provides faster performance on for certain functions than base R, through its use of MKL, an implementation of BLAS (as described above). Revolution R is available as a free and open source product, ‘Revolution R Open’ (RRO), and is reported to be faster than base R installations.<a href="#fn7" class="footnoteRef" id="fnref7"><sup>7</sup></a></p>
<p>Additional benchmarks reported by <span class="citation">Eddelbuettel (<a href="#ref-eddelbuettel2010benchmarking">2010</a>)</span> show the MKL implementations of R used in RRO and the commercial edition to be substantially faster than the reference case.</p>
</div>
<div id="other-interpreters" class="section level3">
<h3><span class="header-section-number">3.5.2</span> Other interpreters</h3>
<p>The R <em>language</em> can be separated from the R <em>interpreter</em>. The former refers to the meaning of R commands, the latter refers to how the computer executes the commands. Alternative interpreters have been developed to try to make R faster and, while promising, none of the following options has fully taken off.</p>
<ul>
<li><p><a href="http://www.pqr-project.org/">pqrR</a> (pretty quick R) is a new version of the R interpreter. One major downside, is that it is based on R-2.15.0. The developer (Radford Neal) has made many improvements, some of which have now been incorporated into base R. <strong>pqR</strong> is an open-source project licensed under the GPL. One notable improvement in pqR is that it is able to do some numeric computations in parallel with each other, and with other operations of the interpreter, on systems with multiple processors or processor cores.</p></li>
<li><p><a href="http://www.renjin.org/">Renjin</a> reimplements the R interpreter in Java, so it can run on the Java Virtual Machine (JVM). Since R will be pure Java, it can run anywhere.</p></li>
<li><p><a href="http://spotfire.tibco.com/">Tibco</a> created a C++ based interpreter called TERR.</p></li>
<li><p>Oracle also offer an R-interpreter that uses Intel’s mathematics library and therefore achieves a higher performance without changing R’s core.</p></li>
</ul>
<p>At the time of writing, switching interpreters is something to consider carefully. But in the future, it may become more routine.</p>
<p>In this context it is also worth mentioning <a href="http://julialang.org/">Julia</a>. This is a fast language and interpreter which aims to provide “a high-level, high-performance dynamic programming language for technical computing” that will be familiar to R and Python users.</p>
</div>
<div id="useful-blasbenchmarking-resources" class="section level3">
<h3><span class="header-section-number">3.5.3</span> Useful BLAS/benchmarking resources</h3>
<ul>
<li>The <a href="https://cran.r-project.org/web/packages/gcbd/">gcbd</a> package benchmarks performance of a few standard linear algebra operations across a number of different BLAS libraries as well as a GPU implementation. It has an excellent vignette summarising the results.</li>
<li><a href="http://brettklamer.com/diversions/statistical/faster-blas-in-r/">Brett Klamer</a> provides a nice comparison of ATLAS, OpenBLAS and Intel MKL BLAS libraries. He also gives a description of how to install the different libraries.</li>
<li>The official R manual <a href="https://cran.r-project.org/doc/manuals/r-release/R-admin.html#BLAS">section</a> on BLAS.</li>
</ul>
</div>
<div id="exercises-5" class="section level3">
<h3><span class="header-section-number">3.5.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li>What BLAS system is your version of R using?</li>
</ol>
<!--chapter:end:02-set-up.Rmd-->
</div>
</div>
</div>
<div id="efficient-hardware" class="section level1">
<h1><span class="header-section-number">4</span> Efficient hardware</h1>
<p>In the previous chapter we saw how relatively simple tweaks to our system set-up can result in substantial time savings. In this chapter we explore the relationship between computer hardware and the speed of code execution. The goal is to help you decide whether the benefits of upgrading your hardware are worth the cost.</p>
<p>We’ll begin with an introductory section on computer storage and memory and how it is measured, before moving on to individual computer components.</p>
<div id="introduction-what-is-a-byte" class="section level2">
<h2><span class="header-section-number">4.1</span> Introduction: what is a byte?</h2>
<p>A computer cannot store “numbers” or “letters”. The only thing a computer can store and work with is bits. A bit is binary, it is either a <span class="math inline">\(0\)</span> or a <span class="math inline">\(1\)</span>. In fact from a physics perspective, a bit is just a blip of electricity that either is or isn’t there.</p>
<p>In the past the ASCII character set dominated computing. This set defines <span class="math inline">\(128\)</span> characters including <span class="math inline">\(0\)</span> to <span class="math inline">\(9\)</span>, upper and lower case alpha-numeric and a few control characters such as a new line. To store these characters required <span class="math inline">\(7\)</span> bits since <span class="math inline">\(2^7 = 128\)</span>, but <span class="math inline">\(8\)</span> bits were typically used for performance <a href="http://stackoverflow.com/q/14690159/203420">reasons</a>. Table 3.1 gives the binary representation of the first few characters.</p>
<table>
<thead>
<tr class="header">
<th align="left">Bit representation</th>
<th align="left">Character</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(01000001\)</span></td>
<td align="left">A</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(01000010\)</span></td>
<td align="left">B</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(01000011\)</span></td>
<td align="left">C</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(01000100\)</span></td>
<td align="left">D</td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(01000101\)</span></td>
<td align="left">E</td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(01010010\)</span></td>
<td align="left">R</td>
</tr>
</tbody>
</table>
<p>Table 3.1: The bit representation of a few ASCII characters.</p>
<p>The limitation of only gives having <span class="math inline">\(256\)</span> characters led to the development of Unicode, a standard framework aimed at creating a single character set for every reasonable writing system. Typically, Unicode characters require sixteen bits of storage.</p>
<p>Eight bits is one byte, or ASCII character. So two ASCII characters would use two bytes or <span class="math inline">\(16\)</span> bits. A pure text document containing <span class="math inline">\(100\)</span> characters would use <span class="math inline">\(100\)</span> bytes (<span class="math inline">\(800\)</span> bits). Note that mark-up, such as font information or meta-data, can impose a substantial memory overhead: an empty <code>.docx</code> file requires about <span class="math inline">\(3,700\)</span> bytes of storage.</p>
<p>When computer scientists first started to think about computer memory, they noticed that <span class="math inline">\(2^{10} = 1024 \simeq 10^3\)</span> and <span class="math inline">\(2^{20} =1,048,576\simeq 10^6\)</span>, so they adopted the short hand of kilo- and mega-bytes. Of course, <em>everyone</em> knew that it was just a short hand, and it was really a binary power. When computers became more wide spread, foolish people like you and me just assumed that kilo actually meant <span class="math inline">\(10^3\)</span> bytes.</p>
<p>Fortunately the IEEE Standards Board intervened and created conventional, internationally adopted definitions of the International System of Units (SI) prefixes. So a kilobyte (KB) is <span class="math inline">\(10^3 = 1000\)</span> bytes and a megabyte (MB) is <span class="math inline">\(10^6\)</span> bytes or <span class="math inline">\(10^3\)</span> kilobytes (see table 3.2). A petabyte is approximately <span class="math inline">\(100\)</span> million drawers filled with text. Astonishingly Google processes around <span class="math inline">\(20\)</span> petabytes of data every day.</p>
<table style="width:65%;">
<colgroup>
<col width="11%" />
<col width="11%" />
<col width="13%" />
<col width="12%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Factor</th>
<th align="left">Name</th>
<th align="left">Symbol</th>
<th align="left">Origin</th>
<th align="left">Derivation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(2^{10}\)</span></td>
<td align="left">kibi</td>
<td align="left">Ki</td>
<td align="left">Kilobinary:</td>
<td align="left"><span class="math inline">\((2^{10})^1\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(2^{20}\)</span></td>
<td align="left">mebi</td>
<td align="left">Mi</td>
<td align="left">Megabinary:</td>
<td align="left"><span class="math inline">\((2^{10})^2\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(2^{30}\)</span></td>
<td align="left">gibi</td>
<td align="left">Gi</td>
<td align="left">Gigabinary:</td>
<td align="left"><span class="math inline">\((2^{10})^3\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(2^{40}\)</span></td>
<td align="left">tebi</td>
<td align="left">Ti</td>
<td align="left">Terabinary:</td>
<td align="left"><span class="math inline">\((2^{10})^4\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(2^{50}\)</span></td>
<td align="left">pebi</td>
<td align="left">Pi</td>
<td align="left">Petabinary:</td>
<td align="left"><span class="math inline">\((2^{10})^5\)</span></td>
</tr>
</tbody>
</table>
<p>Table 3.2: Data conversion table. Credit: <a href="physics.nist.gov/cuu/Units/binary.html">http://physics.nist.gov/cuu/Units/binary.html</a></p>
<p>Even though there is now an agreed standard for discussing memory, that doesn’t mean that everyone follows it. Microsoft Windows, for example, uses 1MB to mean <span class="math inline">\(2^{20}\)</span>B. Even more confusing the capacity of a <span class="math inline">\(1.44\)</span>MB floppy disk is a mixture, <span class="math inline">\(1\text{MB} = 10^3 \times 2^{10}\)</span>B.</p>
</div>
<div id="ram" class="section level2">
<h2><span class="header-section-number">4.2</span> Random access memory: RAM</h2>
<p>Random access memory (RAM) is a type of computer memory that can be accessed randomly: any byte of memory can be accessed without touching the preceding bytes. RAM is found in computers, phones, tablets and even printers. The amount of RAM R has access to is directly related to the size of data sets that it can process. As the amount of RAM your machine has increases, the size of datasets you can analyse also increases, so it is important to have sufficient RAM for your work.</p>
<div class="figure">
<img src="figures/ram.jpg" alt="(\#fig:3-1)Two $8$GB RAM cards. Credit: https://commons.wikimedia.org/wiki/File:Two_8_GB_DDR4-2133_ECC_1.2_V_RDIMMs.jpg"  />
<p class="caption">
(#fig:3-1)Two <span class="math inline">\(8\)</span>GB RAM cards. Credit: <a href="https://commons.wikimedia.org/wiki/File:Two_8_GB_DDR4-2133_ECC_1.2_V_RDIMMs.jpg" class="uri">https://commons.wikimedia.org/wiki/File:Two_8_GB_DDR4-2133_ECC_1.2_V_RDIMMs.jpg</a>
</p>
</div>
<p>Even if the original data set is relatively small, the analysis can generate large objects. For example, suppose we want to perform standard cluster analysis. The built-in data set <code>USAarrests</code>, is a data frame with <span class="math inline">\(50\)</span> rows and <span class="math inline">\(4\)</span> columns. Each row corresponds to a state in the USA</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(USArrests, <span class="dv">3</span>)</code></pre></div>
<pre><code>##         Murder Assault UrbanPop Rape
## Alabama   13.2     236       58 21.2
## Alaska    10.0     263       48 44.5
## Arizona    8.1     294       80 31.0</code></pre>
<p>If we want to group states that have similar crime statistics, a standard first step is to calculate the distance or similarity matrix</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">d =<span class="st"> </span><span class="kw">dist</span>(USArrests)</code></pre></div>
<p>When we inspect the object size of the original data set and the distance object using the <strong>pryr</strong> package</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr::<span class="kw">object_size</span>(USArrests)</code></pre></div>
<pre><code>## 5.23 kB</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr::<span class="kw">object_size</span>(d)</code></pre></div>
<pre><code>## 14.3 kB</code></pre>
<p>we have managed to create an object that is three times larger than the original data set. In fact the object <code>d</code> is a symmetric <span class="math inline">\(n \times n\)</span> matrix, where <span class="math inline">\(n\)</span> is the number of rows in <code>USAarrests</code>. Clearly, as <code>n</code> increases the size of <code>d</code> increases at rate <span class="math inline">\(O(n^2)\)</span>. So if our original data set contained <span class="math inline">\(10,000\)</span> records, the associated distance matrix would contain almost <span class="math inline">\(10^8\)</span> values. Of course since the matrix is symmetric, this corresponds to around <span class="math inline">\(50\)</span> million unique values. A rough rule of thumb is that your RAM should be three times the size of your data set.</p>
<p>Another benefit of having increasing the amount of onboard RAM is that the ‘garbage collector’, a process that runs periodically to free-up system memory occupied by R, is called less often (we will cover this in more detail in chapter XXX).</p>
<p>It is straightforward to determine how much RAM you have. Under Windows,</p>
<ol style="list-style-type: decimal">
<li>Clicking the <code>Start</code> button picture of the Start button, then right-clicking Computer. Next click on <code>Properties</code>.</li>
<li>In the <code>System</code> section, you can see the amount of RAM your computer has next to the <code>Installed memory (RAM)</code> section. Windows reports how much RAM it can use, not the amount installed. This is only an issue if you are using a 32-bit version of Windows.</li>
</ol>
<p>In Mac, click the Apple menu. Select <code>About This Mac</code> and a window appears with the relevant information.</p>
<p>On almost all Unix-based OSs, you can find out how much RAM you have using the code <code>vmstat</code>, whilst on all Linux distributions, you can use the command <code>free</code>. Using this in conjunction with the <code>-h</code> tag will provide the answer in human readable format, as illustrated below for a 16 GB machine:</p>
<pre><code>$ free -h
             total       used       free     
Mem:           15G       4.0G        11G </code></pre>
<p>It is sometimes possible to increase your computer’s RAM. On the computer motherboard, there are typically <span class="math inline">\(2\)</span> or <span class="math inline">\(4\)</span> RAM or memory slots. If you have free slots, then you can add more RAM. However, it is common that all slots are already taken. This means that to upgrade your computer’s memory, some or all of the RAM will have to be removed. To go from <span class="math inline">\(8\)</span>GB to <span class="math inline">\(16\)</span>GB, for example, you may have to discard the two <span class="math inline">\(4\)</span>GB RAM cards and replace them with two <span class="math inline">\(8\)</span>GB cards. Increasing your laptop/desktop from 4GB to <span class="math inline">\(16\)</span>GB or <span class="math inline">\(32\)</span>GB is cheap and should definitely be considered. As R Core member Uwe Ligges states,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fortunes::<span class="kw">fortune</span>(<span class="dv">192</span>)</code></pre></div>
<pre><code>## 
## RAM is cheap and thinking hurts.
##    -- Uwe Ligges (about memory requirements in R)
##       R-help (June 2007)</code></pre>
<p>It is a testament to the design of R that it is still relevant and its popularity is growing. Ross Ihaka, one of the originators of the R programming language, made a throw-away comment in 2003:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fortunes::<span class="kw">fortune</span>(<span class="dv">21</span>)</code></pre></div>
<pre><code>## 
## I seem to recall that we were targetting 512k Macintoshes. In our dreams
## we might have seen 16Mb Sun.
##    -- Ross Ihaka (in reply to the question whether R&amp;R thought when they
##       started out that they would see R using 16G memory on a dual Opteron
##       computer)
##       R-help (November 2003)</code></pre>
<p>Considering that a standard smart phone now contains <span class="math inline">\(1\)</span>GB of RAM, the fact that R was designed for “basic” computers, but can scale across clusters is impressive. R’s origins on computers with limited resources helps explain its efficiency at dealing with large datasets.</p>
<div id="exercises-6" class="section level3">
<h3><span class="header-section-number">4.2.1</span> Exercises</h3>
<p>The following two exercises aim to help you determine if it is worthwhile upgrading your RAM.</p>
<ol style="list-style-type: decimal">
<li>R loads everything into memory, i.e. your computers RAM. How much RAM do you have?</li>
<li>Using Google, how much does it cost (in pounds) to double the amount of available RAM on your system?</li>
</ol>
</div>
</div>
<div id="hard-drives-hdd-vs-ssd" class="section level2">
<h2><span class="header-section-number">4.3</span> Hard drives: HDD vs SSD</h2>
<p>Unless you have a fairly expensive laptop your computer probably has a standard hard disk drive (HDD). HDDs were first introduced by IBM in 1956. Data is stored using magnetism on a rotating platter, as shown in Figure @ref(fig:3-2). The faster the platter spins, the faster the HDD can perform. Many laptop drives spin at either <span class="math inline">\(5400\)</span>RPM (Revolutions per Minute) or <span class="math inline">\(7200\)</span>RPM. The major advantage of HDDs is that they are cheap, making a <span class="math inline">\(1\)</span>TB laptop standard.</p>
<div class="figure">
<img src="figures/627px-Laptop-hard-drive-exposed.jpg" alt="(\#fig:3-2)A standard 2.5" hard drive, found in most laptops. Credit: https://en.wikipedia.org/wiki/Hard_disk_drive"  />
<p class="caption">
(#fig:3-2)A standard 2.5&quot; hard drive, found in most laptops. Credit: <a href="https://en.wikipedia.org/wiki/Hard_disk_drive" class="uri">https://en.wikipedia.org/wiki/Hard_disk_drive</a>
</p>
</div>
<p>Solid state drives (SSDs) can be thought of as large, but more sophisticated versions of USB sticks. They have no moving parts and information is stored in microchips. Since there are no moving parts, reading/writing is much quicker. SSDs have other benefits: they are quieter, allow faster boot time (no ‘spin up’ time) and require less power (more battery life).</p>
<p>The read/write speed for a standard HDD is usually in the region of <span class="math inline">\(50-120\)</span>MB/s (usually closer to <span class="math inline">\(50\)</span>MB). For SSDs, speeds are typically over <span class="math inline">\(200\)</span>MB/s. For top-of-the-range models this can approach <span class="math inline">\(500\)</span>MB/s. If you’re wondering, read/write speeds for RAM is around <span class="math inline">\(2-20\)</span>GB/s. So at best SSDs are at least one order of magnitude slower than RAM, but still faster than standard HDDs.</p>
</div>
<div id="operating-systems-32-bit-or-64-bit" class="section level2">
<h2><span class="header-section-number">4.4</span> Operating systems: 32-bit or 64-bit</h2>
<p>When we suggest that you should just buy more RAM, this assumes that you are using a <span class="math inline">\(64\)</span>-bit operating system. A <span class="math inline">\(32\)</span>-bit machine can access at most only <span class="math inline">\(4\)</span>GB of RAM. Although some CPUs offer solutions to this limitation, if you are running a <span class="math inline">\(32\)</span>-bit operating system, then R is limited to around <span class="math inline">\(3\)</span>GB RAM. If you are running a <span class="math inline">\(64\)</span>-bit operating system, but only a <span class="math inline">\(32\)</span>-bit version of R, then you have access to slightly more memory (but not much). Modern systems should run a <span class="math inline">\(64\)</span>-bit operating system, with a <span class="math inline">\(64\)</span>-bit version of R. Your memory limit is now measured as <span class="math inline">\(8\)</span> terabytes for Windows machines and <span class="math inline">\(128\)</span>TB for Unix-based OSs.</p>
<p>To find precise details consult the R help pages <code>help(&quot;Memory-limits&quot;)</code> and <code>help(&quot;Memory&quot;)</code>.</p>
<div id="exercises-7" class="section level3">
<h3><span class="header-section-number">4.4.1</span> Exercises</h3>
<p>These exercises aim to condense the previous section into the key points.</p>
<ol style="list-style-type: decimal">
<li>Are you using a <span class="math inline">\(32\)</span>-bit or <span class="math inline">\(64\)</span>-bit operating system?</li>
<li>Are you using <span class="math inline">\(32\)</span>-bit or <span class="math inline">\(64\)</span>-bit version of R?</li>
<li>What are the results of running the command <code>memory.limit()</code>?</li>
</ol>
</div>
</div>
<div id="central-processing-unit-cpu" class="section level2">
<h2><span class="header-section-number">4.5</span> Central processing unit (CPU)</h2>
<p>The central processing unit (CPU), or the processor, is the brains of a computer. The CPU is responsible for performing numerical calculations. The faster the processor, the faster our code will run. The clock speed (or clock rate, measured in hertz) is frequency with which the CPU executes instructions. The faster the clock speed, the more instructions a CPU can execute in a section. CPU clock speed for a single CPU has been fairly static in the last couple of years, hovering around 3.4GHz (see figure @ref(fig:3-3)).</p>
<div class="figure">
<img src="_main_files/figure-html/3-3-1.png" alt="(\#fig:3-3)CPU clock speed. The data for this figure was collected from web-forum and wikipedia. It is intended to indicate general trends in CPU speed."  />
<p class="caption">
(#fig:3-3)CPU clock speed. The data for this figure was collected from web-forum and wikipedia. It is intended to indicate general trends in CPU speed.
</p>
</div>
<p>Unfortunately we can’t simply use clock speeds to compare CPUs, since the internal architecture of a CPU plays a crucial role in determining the CPU performance. The R package <strong>benchmarkme</strong> provides functions for benchmarking your system and contains data from previous benchmarks. Figure @ref{fig:3-4} shows the relative performance for eight different CPUs. All eight processors are Intel. The fastest processor in this benchmark study was the i7 CPU 870, which was released in 2009. In comparison, the Xeon Processor X3220, released in 2007, is over three times slower.</p>
<div class="figure">
<img src="_main_files/figure-html/3-4-1.png" alt="(\#fig:3-4)CPU benchmarks from the R package, **benchmarkme**. Each point represents an individual CPU result."  />
<p class="caption">
(#fig:3-4)CPU benchmarks from the R package, <strong>benchmarkme</strong>. Each point represents an individual CPU result.
</p>
</div>
</div>
<div id="cloud-computing" class="section level2">
<h2><span class="header-section-number">4.6</span> Cloud computing</h2>
<p>Cloud computing uses networks of remote servers, instead of a local computer, to store and analyse data. It is now becoming increasingly popular to rent cloud computing resources.</p>
<div id="amazon-ec2" class="section level3">
<h3><span class="header-section-number">4.6.1</span> Amazon EC2</h3>
<p>Amazon Elastic Compute Cloud (EC2) is one of a number of providers of this service. EC2 makes it (relatively) easy to run R instances in the cloud. Users can configure the operating system, CPU, hard drive type, the amount of RAM and where your project is physically located.</p>
<p>If you want to run a server in the Amazon EC2 cloud, you have to select the system you are going to boot up. There are a vast array of pre-packaged system images. Some of these images are just basic operating systems, such as Debian or Ubuntu, which require further configuration. There is also an <a href="http://www.louisaslett.com/RStudio_AMI/">Amazon machine image</a> that specifically targets R and RStudio.</p>
</div>
<div id="exercise" class="section level3">
<h3><span class="header-section-number">4.6.2</span> Exercise</h3>
<p>To assess whether you should consider cloud computing, how much does it cost to rent a machine comparable to your laptop in the cloud?</p>
<!--chapter:end:03-hardware.Rmd-->
</div>
</div>
</div>
<div id="efficient-workflow" class="section level1">
<h1><span class="header-section-number">5</span> Efficient workflow</h1>
<p>Efficient programming is an important and sometimes vital skill for generating the correct result, on time. Yet coding is only one part of a wider skillset needed for successful project outcomes which involve R programming. In this context we define ‘workflow’ as the sum of practices, habits and systems that enable productivity.<a href="#fn8" class="footnoteRef" id="fnref8"><sup>8</sup></a> To some extent workflow is about personal preferences. Everyone’s mind works differently so the most appropriate workflow varies from person to person and from one project to the next. We recommend trying different working practices to discover which works best for you.<a href="#fn9" class="footnoteRef" id="fnref9"><sup>9</sup></a></p>
<p>There are, however, concrete steps that can be taken to improve workflow in most projects that involve R programming. Learning them will, in the long-run, improve productivity and reproducibility. With these motivations in mind, the purpose of this chapter is simple: to highlight some key ingredients of an efficient R workflow. It builds on the concept of an R/RStudio <em>project</em>, introduced in Chapter 2, and is ordered chronologically throughout the stages involved in a typical project’s lifespan, from its inception to publication:</p>
<ul>
<li><p>Project planning. This should happen before any code has been written, to avoid time wasted using poor packages or a mistaken analysis strategy.</p></li>
<li><p>Package selection. After planning your project you should identify which packages are most suitable to get the work done quickly and effectively. With the burgeoning number of packages available, and the phenomenon that some R packages now perform better than base R for certain functions (<code>*_join</code>, for example, is better than <code>merge</code>).</p></li>
<li><p>Importing data. This can depend on external packages and represent a time-consuming and computational bottle-neck that prevents progress.</p></li>
<li><p>Tidying the data. This critical stage results in datasets that are convenient for analysis and processing, with implications for the efficiency of all subsequent stages <span class="citation">(Wickham <a href="#ref-Wickham_2014">2014</a><a href="#ref-Wickham_2014">b</a>)</span>.</p></li>
<li><p>Data processing. This stage involves manipulating data to assist in the answering of hypotheses. The focus is on the <strong>dplyr</strong> and <strong>data.table</strong> packages. These are designed to make this stage both fast to type process.</p></li>
<li><p>Publication. This final stage is relevant if you want your R code to be useful for others in the long term. To this end Section @ref(publication) touches on documentation using knitr and the much stricter approach to code publication of package development.</p></li>
</ul>
<div id="project-planning" class="section level2">
<h2><span class="header-section-number">5.1</span> Project planning</h2>
<p>Good programmers embarking on a complex project will rarely just start typing code. Instead, they will plan the steps needed to complete the task as efficiently as possible: “smart preparation minimizes work” <span class="citation">(Berkun <a href="#ref-berkun2005art">2005</a>)</span>. Although search engines are useful for identifying the appropriate strategy, the trail-and-error approach — typing code at random and Googling the inevitable error messages — is usually highly <em>inefficient</em>. Strategic thinking is necessary.</p>
<p>Often the best place to start is often with a pen and paper. Project planning is a non-linear, open-ended and creative process not always well-suited to the linear logic of computing.<a href="#fn10" class="footnoteRef" id="fnref10"><sup>10</sup></a> Planning simply involves thinking about the project’s aims in the context of available resources (e.g. computational vs programming skill), the project’s scope, timelines and suitable software (i.e. R packages, covered in the next section). Minutes spent before a single line of code is written have the potential to save hours later on. There are many excellent guides available that will help you develop a project plan.</p>
<p>Once a project overview has been devised and stored, in mind (for small projects, if you trust that as storage medium!) or written, a plan with a time-line can be drawn-up. The up-to-date visualisation of this plan can be a powerful reminder to yourself and collaborators of progress on the project so far. More importantly the timeline provides an overview of what needs to be done next. Setting start dates and deadlines for each task will help prioritise the work and ensure you are on track. Breaking a large project into smaller chunks is highly recommended, making huge, complex tasks more achievable and modular <span class="citation">PMBoK (<a href="#ref-PMBoK_2000">2000</a>)</span>. ‘Chunking’ the work will also make collaboration easier, as we shall see in Chapter 5.</p>
<div class="figure">
<img src="_main_files/figure-html/phases-1.png" alt="(\#fig:phases)Schematic illustrations of key project phases and levels of activity over time, based on @PMBoK_2000."  />
<p class="caption">
(#fig:phases)Schematic illustrations of key project phases and levels of activity over time, based on <span class="citation">PMBoK (<a href="#ref-PMBoK_2000">2000</a>)</span>.
</p>
</div>
<p>The tasks that a project should be split into will depend the nature of the work and the phases illustrated in Figure @ref(fig:phases) represent a rough starting point, not a template and the ‘programming’ phase will usually need to be split into at least ‘data tidying’, ‘processing’, and ‘visualisation’.</p>
<p>A more rigorous (but potentially onerous) way to project plan is to divide the work into a series of objectives and tracking their progress throughout the project’s duration. One way to check if an objective is appropriate for action and review is by using the SMART criteria.</p>
<ul>
<li>Specific: is the objective clearly defined and self-contained?</li>
<li>Measurable: is there a clear indication of its completion?</li>
<li>Attainable: can the target be achieved?</li>
<li>Realistic: have sufficient resources been allocated to the task?</li>
<li>Time-bound: is there an associated completion date or milestone?</li>
</ul>
<p>If the answer to each of these questions is ‘yes’, the task is likely to be suitable to include in the project’s plan. Note that this does not mean all project plans need to be uniform. A project plan can take many forms, including a short document, a Gantt chart (see Figure @ref(fig:timeline) or simply a clear vision of the project’s steps in mind.</p>
<div class="figure">
<img src="figures/DiagrammeR-gantt-book.png" alt="(\#fig:timeline)A Gantt chart created using **DiagrammeR** illustrating the steps needed to complete this book at an early stage of its development."  />
<p class="caption">
(#fig:timeline)A Gantt chart created using <strong>DiagrammeR</strong> illustrating the steps needed to complete this book at an early stage of its development.
</p>
</div>
<p>A number of R packages can assist with this process of formalising and visualising the project plan, including:<a href="#fn11" class="footnoteRef" id="fnref11"><sup>11</sup></a></p>
<ul>
<li><p><a href="https://cran.r-project.org/web/packages/plan/">plan</a> provides basic tools to create burndown charts (which concisely show whether a project is on-time or not) and Gantt charts.</p></li>
<li><p><a href="https://cran.r-project.org/web/packages/plotrix/index.html">plotrix</a>, a general purpose plotting package, provides basic Gantt chart plotting functionality. See <code>example(gantt.chart)</code> for details.</p></li>
<li><p><a href="http://rich-iannone.github.io/DiagrammeR/"><strong>DiagrammeR</strong></a>, a new package for creating network graphs and other schematic diagrams in R. This package provides an R interface to simple flow-chart file formats such as <a href="https://github.com/knsv/mermaid">mermaid</a> and <a href="https://github.com/ellson/graphviz">GraphViz</a>.</p></li>
</ul>
<p>The small example below (which provides the basis for creating charts like Figure @ref(fig:timeline) illustrates how <strong>DiagrammeR</strong> can take simple text inputs to create informative up-to-date Gantt charts. Such charts can greatly help with the planning and task management of long and complex R projects, as long as they do not take away valuable programming time from core project objectives.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;DiagrammeR&quot;</span>) <span class="co"># load the necessary package</span>

<span class="co"># define the Gantt chart and plot the result (not shown)</span>
<span class="kw">mermaid</span>(<span class="st">&quot;gantt</span>
<span class="st">        Section Initiation</span>
<span class="st">        Planning           :a1, 2016-01-01, 10d</span>
<span class="st">        Data processing    :after a1  , 30d&quot;</span>)</code></pre></div>
<p>In the above code <code>gantt</code> defines the subsequent data layout. <code>Section</code> refers to the project’s section (useful for large projects, with milestones) and each new line refers to a discrete task. <code>Planning</code>, for example, has the code <code>a</code>, begins on the first day of 2016 and lasts for 10 days. See <a href="http://knsv.github.io/mermaid/gantt.html">knsv.github.io/mermaid/gantt.html</a> for more detailed documentation.</p>
<div id="exercises-8" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>What are the three most important work ‘chunks’ of your current R project?</p></li>
<li><p>What is the meaning of ‘SMART’ objectives?</p></li>
<li><p>Run the code chunk at the end of this section to see the output.</p></li>
<li><p>Bonus exercise: modify the code to create a very basic Gantt chart of an R project you are working on.</p></li>
</ol>
</div>
</div>
<div id="pkgs" class="section level2">
<h2><span class="header-section-number">5.2</span> Package selection</h2>
<p>A good example of the importance of prior planning to minimise effort is package selection. An inefficient, poorly supported or simply outdated package can waste hours. When a more appropriate alternative is available this waste can be prevented by prior planning. There are many poor packages on CRAN and much duplication so it’s easy to go wrong. Just because a certain package <em>can</em> solve a particular problem, doesn’t mean that it <em>should</em>.</p>
<p>However, used well, packages can greatly improve productivity. Due to the conservative nature base R development, which prioritises stability, much of the innovation and performance gains in the ‘R ecosystem’ has occurred in recent years in the packages. The increased ease of package development <span class="citation">(Wickham <a href="#ref-Wickham_2015">2015</a>)</span> and interfacing with other languages <span class="citation">(e.g. Eddelbuettel et al. <a href="#ref-Eddelbuettel_2011">2011</a>)</span> has accelerated their number, quality and efficiency. An additional factor has been the growth in collaboration and peer review in package development, driven by code-sharing websites such as GitHub and online communities such as <a href="https://ropensci.org/">ROpenSci</a> for peer reviewing code.</p>
<p>Performance, stability and ease of use should be high on the priority list when choosing which package to use. Another more subtle factor is that some packages work better together than others. The ‘R package ecosystem’ is composed of interrelated package. Knowing something of these inter-dependencies can help select a ‘package suite’ when the project demands a number of diverse yet interrelated programming tasks. The ‘hadleyverse’, for example, contains many interrelated packages that work well together, such as <strong>readr</strong>, <strong>tidyr</strong>, and <strong>dplyr</strong>.<a href="#fn12" class="footnoteRef" id="fnref12"><sup>12</sup></a> These may be used together to read-in, tidy and then process the data, as outlined in the subsequent sections.</p>
<p>There is no ‘hard and fast’ rule about which package you should use and new packages are emerging all the time. The ultimate test will be empirical evidence: does it get the job done on your data? However, the following criteria should provide a good indication of whether a package is worth an investment of your precious time, or even installing on your computer:</p>
<ul>
<li><p>Is it mature? The more time a package is available, the more time it will have for obvious bugs to be ironed out. The age of a package on CRAN can be seen from its Archive page on CRAN. We can see from <a href="https://cran.r-project.org/src/contrib/Archive/ggplot2/">cran.r-project.org/src/contrib/Archive/ggplot2/</a>, for example, that <strong>ggplot2</strong> was first released on the 10<sup>th</sup> June 2007 and that it has had 28 releases. The most recent of these at the time of writing was <strong>ggplot2</strong> 2.0.0: reaching 1 or 2 in the first digit of package versions is usually an indication from the package author that the package has reached a high level of stability.</p></li>
<li><p>Is it actively developed? It is a good sign if packages are frequently updated. A frequently updated package will have its latest version ‘published’ recently on CRAN. The CRAN package page for <strong>ggplot2</strong>, for example, said <code>Published: 2015-12-18</code>, less than a month old at the time of writing.</p></li>
<li><p>Is it well documented? This is not only an indication of how much thought, care and attention has gone into the package. It also has a direct impact on its ease of use. Using a poorly documented package can be inefficient due to the hours spent trying to work out how to use it! To check if the package is well documented, look at the help pages associated with its key functions (e.g. <code>?ggplot</code>), try the examples (e.g. <code>example(ggplot)</code>) and search for package vignettes (e.g. <code>vignette(package = &quot;ggplot2&quot;)</code>).</p></li>
<li><p>Is it well used? This can be seen by searching for the package name online. Most packages that have a strong user base will produce thousands of results when typed into a generic search engine such as Google’s. More specific (and potentially useful) indications of use will narrow down the search to particular users. A package widely used by the programming community will likely visible GitHub. At the time of writing a search for <a href="https://github.com/search?utf8=%E2%9C%93&amp;q=ggplot2"><strong>ggplot2</strong></a> on GitHub yielded over 400 repositories and almost 200,000 matches in committed code! Likewise, a package that has been adopted for use in academia will tend to be mentioned in Google Scholar (again, <strong>ggplot2</strong> scores extremely well in this measure, with over 5000 hits).</p></li>
</ul>
<p>An article in <a href="http://simplystatistics.org/2015/11/06/how-i-decide-when-to-trust-an-r-package/">simplystats</a> discusses this issue with reference to the proliferation of GitHub packages (those that are not available on CRAN). In this context well-regarded and experienced package creators and ‘indirect data’ such as amount of GitHub activity are also highlighted as reasons to trust a package.</p>
</div>
<div id="importing-data" class="section level2">
<h2><span class="header-section-number">5.3</span> Importing data</h2>
<p>Before reading in data, it is worth considering a general principle for reproducible data management: never modify raw data files. Raw data should be seen as read-only, and contain information about its provenance. Keeping the original file name and including a comment about its origin are a couple of ways to improve reproducibility, even when the data are not publicly available. This is illustrated below with functions <code>download.file</code><a href="#fn13" class="footnoteRef" id="fnref13"><sup>13</sup></a> and <code>unzip</code> to download and unzip the dataset,<a href="#fn14" class="footnoteRef" id="fnref14"><sup>14</sup></a> illustrating how R can be used to automate processes that are conventionally done by hand. The result is data stored in the <code>data</code> directory ready to be read-in (note part of the dataset is also stored in the <strong>efficient</strong> package).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">url =<span class="st"> &quot;https://www.monetdb.org/sites/default/files/voc_tsvs.zip&quot;</span>
<span class="kw">download.file</span>(url, <span class="st">&quot;voc_tsvs.zip&quot;</span>) <span class="co"># download file</span>
<span class="kw">unzip</span>(<span class="st">&quot;voc_tsvs.zip&quot;</span>, <span class="dt">exdir =</span> <span class="st">&quot;data&quot;</span>) <span class="co"># unzip files</span>
<span class="kw">file.remove</span>(<span class="st">&quot;voc_tsvs.zip&quot;</span>) <span class="co"># tidy up by removing the zip file</span></code></pre></div>
<p>To avoid the file download stage, many functions for reading in data can accept urls and read directly from the internet. This is illustrated below for <code>read.csv()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">url =<span class="st"> &quot;https://www.osha.gov/dep/fatcat/FatalitiesFY10.csv&quot;</span>
df =<span class="st"> </span><span class="kw">read.csv</span>(url)</code></pre></div>
<p>There are now many R packages designed specifically to assist with the download and import of data. The organisation <a href="https://ropensci.org/">ROpenSci</a> supports a number of these. The example below illustrates this using the WDI package (not supported by ROpenSci) which accesses the World Bank’s World Development Indicators:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;WDI&quot;</span>) <span class="co"># load the WDI library (must be installed)</span>
<span class="kw">WDIsearch</span>(<span class="st">&quot;CO2&quot;</span>) <span class="co"># search for data on a topic</span>
df =<span class="st"> </span><span class="kw">WDI</span>(<span class="dt">indicator =</span> <span class="st">&quot;EN.CO2.TRAN.ZS&quot;</span> ) <span class="co"># import data</span></code></pre></div>
<p>There will be situations where you cannot download the data directly or when the data cannot be made available. In this case, simply providing a comment relating to the data’s origin (e.g. <code># Downloaded from http://example.com</code>) before referring to the dataset can greatly improve the utility of the code to yourself and others.</p>
<div id="fast-data-reading" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Fast data reading</h3>
<p>There is often more than one way to read data into R. Even a simple <code>.csv</code> file can be imported using a range of methods, with implications for computational efficiency. This section looks at three approaches: base R’s reading functions such as <code>read.csv</code>, which are derived from <code>read.table</code>; the <strong>data.table</strong> approach, which uses the function <code>fread</code>; and the new <strong>readr</strong> package which provides <code>read_csv</code> and other <code>read_</code> functions such as <code>read_tsv</code>.</p>
<p>Although this section is focussed on reading text files, it demonstrate the wider principle that the speed and flexibility advantages of additional read functions can be offset by the disadvantages of addition package dependency (in terms of complexity and maintaining the code) for small datasets. The real benefits kick in on large datasets. Of course, there are some data types that <em>require</em> a certain package to load in R: the readstata13 package, for example, was developed solely to read in <code>.dta</code> files generated by versions of Stata 13 and above.</p>
<p>Figure @ref(fig:readr-vs-base) demonstrates that the relative performance gains of the <strong>data.table</strong> and <strong>readr</strong> approaches increase with data size, especially so for data with many rows. Below around 1 MB <code>read.csv</code> is actually <em>faster</em> than <code>read_csv</code> while <code>fread</code> is much faster than both, although these savings are likely to be inconsequential for such small datasets.</p>
<p>For files beyond 100 MB in size <code>fread</code> and <code>read_csv</code> can be expected to be around <em>5 times faster</em> than <code>read.csv</code>. This efficiency gain may be inconsequential for a one-off file of 100 MB running on a fast computer (which still take less than a minute with <code>read.csv</code>), but could represent an important speed-up if you frequently load large text files.</p>
<div class="figure">
<img src="_main_files/figure-html/readr-vs-base-1.png" alt="(\#fig:readr-vs-base)Benchmarks of base vs **data.table** vs **readr** functions for reading csv files. The facets ranging from 2 to 200 represent the number of columns."  />
<p class="caption">
(#fig:readr-vs-base)Benchmarks of base vs <strong>data.table</strong> vs <strong>readr</strong> functions for reading csv files. The facets ranging from 2 to 200 represent the number of columns.
</p>
</div>
<p>When tested on a large (4 GB) .csv file it was found that <code>fread</code> and <code>read_csv</code> were almost identical in load times and that <code>read.csv</code> took around 5 times longer. This consumed more than 10 GB of RAM, making it unsuitable to run on many computers (see Section @ref(ram) for more on memory). Note that both <strong>readr</strong> and base methods can be made faster by pre-specifying the column types at the outset, as illustrated in @ref(fig:readr-vs-base) and described in the help files.</p>
<!-- Idea: test the functions on text data -->
<p>In some cases with R programming there is a trade-off between speed and robustness. This is illustrated below with reference to differences in how <strong>readr</strong>, <strong>data.table</strong> and base R approaches handle unexpected values. Table @ref(tab:voyages) shows that <code>read_tsv</code> is around 3 times faster, re-enforcing the point that the benefits of efficient functions increase with dataset size (made with Figure @ref(fig:readr-vs-base)). This is a small (1 MB) dataset: the relative difference between <code>fread</code> and <code>read_</code> functions will tend to decrease as dataset size increases.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fname =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata/voc_voyages.tsv&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;efficient&quot;</span>)
res_v &lt;-<span class="st"> </span><span class="kw">microbenchmark</span>(<span class="dt">times =</span> <span class="dv">10</span>,
  <span class="dt">base_read =</span> voyages_base &lt;-<span class="st"> </span><span class="kw">read.csv</span>(fname, <span class="dt">sep =</span> <span class="st">&quot;</span><span class="ch">\t</span><span class="st">&quot;</span>),
  <span class="dt">readr_read =</span> voyages_readr &lt;-<span class="st"> </span><span class="kw">read_tsv</span>(fname),
  <span class="dt">dt_fread =</span> voyages_dt &lt;-<span class="st"> </span><span class="kw">fread</span>(fname))</code></pre></div>
<table>
<caption>(#tab:voyages)Execution time of base, <strong>readr</strong> and <strong>data.table</strong> functions for reading in a 1 MB dataset relative to the mean execution time of <code>fread</code>, around 0.02 seconds on a modern computer.</caption>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="right">min</th>
<th align="right">mean</th>
<th align="right">max</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">base_read</td>
<td align="right">13.4</td>
<td align="right">17.4</td>
<td align="right">25.4</td>
</tr>
<tr class="even">
<td align="left">readr_read</td>
<td align="right">3.8</td>
<td align="right">4.2</td>
<td align="right">5.0</td>
</tr>
<tr class="odd">
<td align="left">dt_fread</td>
<td align="right">0.9</td>
<td align="right">1.0</td>
<td align="right">1.1</td>
</tr>
</tbody>
</table>
<p>The benchmark above produces warning messages (not shown) for the <code>read_tsv</code> and <code>fread</code> functions but not the slowest base function <code>read.csv</code>. An exploration of these can shed light on the speed/robustness trade-off.</p>
<ul>
<li>The <strong>readr</strong> function generates a warning for row 2841 in the <code>built</code> variable. This is because <code>read_*()</code> decides what class each variable is based on the first 1000 rows, rather than all rows as base <code>read.*</code> functions do. As illustrated by printing the result for the row which generated a warning, the <code>read_tsv</code> output is probably more sensible than the <code>read.csv</code> output: the latter coerced the date field into a factor based on a single entry which is a text whereas the latter coerced the variable into a numeric data, as illustrated below.</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(voyages_base$built) <span class="co"># coerced to a factor</span></code></pre></div>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(voyages_readr$built) <span class="co"># numeric based on first 1000 rows</span></code></pre></div>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">voyages_base$built[<span class="dv">2841</span>] <span class="co"># contains the text responsible for coercion</span></code></pre></div>
<pre><code>## [1] 1721-01-01
## 182 Levels:  1 784 1,86 1135 1594 1600 1612 1613 1614 1615 1619 ... taken 1672</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">voyages_readr$built[<span class="dv">2841</span>] <span class="co"># an NA: text cannot be converted to numeric</span></code></pre></div>
<pre><code>## [1] NA</code></pre>
<ul>
<li>The <strong>data.table</strong> function <code>fread</code> generates 5 warning messages stating that columns 2, 4, 9, 10 and 11 were <code>Bumped to type character on data row ...</code>, with the offending rows printed in place of <code>...</code>. Instead of changing the offending values to <code>NA</code>, as <strong>readr</strong> does for the <code>built</code> column (9), <code>fread</code> automatically converts any columns it thought of as numeric into characters.</li>
</ul>
<p>To summarise, the differences between base, <strong>readr</strong> and <strong>data.table</strong> functions for reading in data go beyond code execution times. The functions <code>read_csv</code> and <code>fread</code> boost speed partially at the expense of robustness because they decide column classes based on a small sample of available data. The similarities and differences between the approaches are summarised for the Dutch shipping data in Table @ref(tab:colclasses), which shows 4 main similarities and differences:</p>
<ul>
<li>For uniform data such as the ‘number’ variable in Table @ref(tab:colclasses), all reading methods yield the same result (integer in this case).</li>
<li>For columns that are obviously characters such as ‘boatname’, the base method results in factors (unless <code>stringsAsFactors</code> is set to <code>TRUE</code>) whereas <code>fread</code> and <code>read_csv</code> functions return characters.</li>
<li>For columns in which the first 1000 rows are of one type but which contain anomalies, such as ‘built’ and ‘departure_data’ in the shipping example, <code>fread</code> coerces the result to characters. <code>read_csv</code> and siblings, by contrast, keep the class that is correct for the first 1000 rows and sets the anomalous records to <code>NA</code>.</li>
<li><code>read_*</code> functions generate objects of class <code>tbl_df</code>, an extension of the <code>data.frame</code>, as discussed in Section @ref(dplyr). <code>fread</code> generates objects of class <code>data.table</code>. These can be used as standard data frames but differ subtly in their behaviour.</li>
</ul>
<table>
<caption>(#tab:colclasses)Execution time of base, <strong>readr</strong> and <strong>data.table</strong> functions for reading in a 1 MB dataset</caption>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">number</th>
<th align="left">boatname</th>
<th align="left">built</th>
<th align="left">departure_date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">base_read</td>
<td align="left">integer</td>
<td align="left">factor</td>
<td align="left">factor</td>
<td align="left">factor</td>
</tr>
<tr class="even">
<td align="left">readr_read</td>
<td align="left">integer</td>
<td align="left">character</td>
<td align="left">numeric</td>
<td align="left">Date</td>
</tr>
<tr class="odd">
<td align="left">dt_fread</td>
<td align="left">integer</td>
<td align="left">character</td>
<td align="left">character</td>
<td align="left">character</td>
</tr>
</tbody>
</table>
<p>The wider point associated with these tests is that functions that save time can also lead to additional considerations or complexities your workflow. Taking a look at what is going on ‘under the hood’ of fast functions to increase speed, as we have done in this section, can help understand the knock-on consequences of choosing fast functions over slower functions from base R.</p>
</div>
<div id="preprocessing-outside-r" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Preprocessing outside R</h3>
<p>There are circumstances when datasets become too large to read directly into R. Reading in 4 GB text file using the functions tested above, for example, consumed all available RAM on an 16 GB machine! To overcome the limitation that R reads all data directly into RAM, external <em>stream processing</em> tools can be used to preprocess large text files. The following command, using the shell command <code>split</code>, for example, would break a large multi GB file many one GB chunks, each of which is more manageable for R:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash"><span class="kw">split</span> -b100m bigfile.csv</code></pre></div>
<p>The result is a series of files, set to 100 MB each with the <code>-b100m</code> argument in the above code. By default these will be called <code>xaa</code>, <code>xab</code> and which could be read in <em>one chunk at a time</em> (e.g. using <code>read.csv</code>, <code>fread</code> or <code>read_csv</code>, described in Section @ref(fast-data-reading)) without crashing most modern computers.</p>
<p>Splitting a large file into individual chunks may allow it to be read into R . But is not an efficient way to import large datasets because you will only ever have access to a non-random sample of the data this way. A more efficient way to work with very large datasets is via databases.</p>
</div>
<div id="working-with-databases" class="section level3">
<h3><span class="header-section-number">5.3.3</span> Working with databases</h3>
<p>Instead of loading all the data into RAM, as R does, databases query data from the hard-disk. This can allow a subset of a very large dataset to be defined and read into R quickly, without having to load it first.</p>
<p>R can connect to databases in a number of ways. The most mature of these is via the RODBC package, which sets up links to external databases using the Open Database Connectivity (ODBC) API, as described in the packages vignette (which can be accessed with <code>vignette(&quot;RODBC&quot;)</code>, once the package has been installed). RODBC connects to ‘traditional’ databases such as MySQL, PostgreSQL, Oracle and SQLite.</p>
<p>The function used to set-up a connection to an external database with RODBC is <code>odbcConnect</code>, which takes Data Source Name (<code>dsn =</code>), User ID (<code>uid =</code>) and password (<code>pwd</code>) as required arguments. Be sure never to release your password by entering it directly into the command. Instead, we recommend saving sensitive information such as database passwords and API keys in <code>.Renviron</code>, described in @ref(renviron). Assuming you had saved your password as the environment variable <code>PSWRD</code>, you could enter <code>pwd = Sys.getenv(&quot;PSWRD&quot;)</code> to minimise the risk of exposing your password through accidentally releasing the code or your session history.</p>
<p>Recently there has been a shift ‘noSQL’ approach to data storage for handling large datasets. This is illustrated by the emergence and uptake of software such as MongoDB and Apache Cassandra, which have R interfaces via packages <a href="https://cran.r-project.org/web/packages/mongolite/index.html">mongolite</a> and <a href="https://cran.r-project.org/web/packages/RJDBC/index.html">RJDBC</a>, which can connect to Apache Cassandra data stores and any source compliant with the Java Database Connectivity (JDBC) API.</p>
<p>MonetDB is a recent alternative to traditional and noSQL approaches which offers substantial efficiency advantages for handling large datasets <span class="citation">(Kersten et al. <a href="#ref-kersten2011researcher">2011</a>)</span>. A tutorial on the <a href="https://www.monetdb.org/Documentation/UserGuide/MonetDB-R">MonetDB website</a> provides an excellent introduction to handling databases from within R. A new development showcased in this tutorial is the ability to interact with databases using exactly the same syntax used to interact with R objects stored in RAM. This innovation was made possible by <strong>dplyr</strong>, an R library for data processing that aims to provide a unified ‘front end’ to perform a wide range of analysis task on datasets using a variety of ‘back ends’ which do the number crunching. This is one of the main advantages of <strong>dplyr</strong> (see Section @ref(dplyr)).</p>
</div>
</div>
<div id="tidying-data-with-tidyr" class="section level2">
<h2><span class="header-section-number">5.4</span> Tidying data with <strong>tidyr</strong></h2>
<p>A key skill in data analysis is understanding the structure of datasets and being able to ‘reshape’ them. This is important from a workflow efficiency perspective: more than half of a data analyst’s time can be spent re-formatting datasets <span class="citation">(Wickham <a href="#ref-Wickham_2014">2014</a><a href="#ref-Wickham_2014">b</a>)</span>. Converting data into a ‘tidy’ form (described below) is also advantageous from a computational efficiency perspective: it usually faster to run analysis and plotting commands on a few large vectors than many short vectors.</p>
<p>This is illustrated by Tables @ref(tab:tpew) and @ref(tab:tpewt), provided by <span class="citation">Wickham (<a href="#ref-Wickham_2014">2014</a><a href="#ref-Wickham_2014">b</a>)</span>.</p>
<table>
<caption>(#tab:tpew)First 6 rows of the aggregated ‘pew’ dataset from Wickham (2014a) in an ‘untidy’ form.</caption>
<thead>
<tr class="header">
<th align="left">religion</th>
<th align="right">&lt;$10k</th>
<th align="right">$10–20k</th>
<th align="right">$20–30k</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Agnostic</td>
<td align="right">27</td>
<td align="right">34</td>
<td align="right">60</td>
</tr>
<tr class="even">
<td align="left">Atheist</td>
<td align="right">12</td>
<td align="right">27</td>
<td align="right">37</td>
</tr>
<tr class="odd">
<td align="left">Buddhist</td>
<td align="right">27</td>
<td align="right">21</td>
<td align="right">30</td>
</tr>
</tbody>
</table>
<table>
<caption>(#tab:tpewt)First 3 and last rows of the ‘tidied’ Pew dataset.</caption>
<thead>
<tr class="header">
<th align="left">religion</th>
<th align="left">Income</th>
<th align="left">Count</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Agnostic</td>
<td align="left">&lt;$10k</td>
<td align="left">27</td>
</tr>
<tr class="even">
<td align="left">Atheist</td>
<td align="left">&lt;$10k</td>
<td align="left">12</td>
</tr>
<tr class="odd">
<td align="left">Buddhist</td>
<td align="left">&lt;$10k</td>
<td align="left">27</td>
</tr>
<tr class="even">
<td align="left">…</td>
<td align="left">…</td>
<td align="left">…</td>
</tr>
<tr class="odd">
<td align="left">Unaffiliated</td>
<td align="left">&gt;150k</td>
<td align="left">258</td>
</tr>
</tbody>
</table>
<p>These tables may look different, but they contain precisely the same information Column names in the ‘flat’ form in Table @ref(tab:tpew) became a new variable in the ‘long’ form in Table @ref(tab:tpewt). According to the concept of ‘tidy data’, the long form is correct. Note that ‘correct’ here is used in the context of data analysis and graphical visualisation. For tabular presentation (i.e. tables) the ‘wide’ or ‘untidy’ form may be better.</p>
<p>Tidy data has the following characteristics <span class="citation">(Wickham <a href="#ref-Wickham_2014">2014</a><a href="#ref-Wickham_2014">b</a>)</span>:</p>
<ol style="list-style-type: decimal">
<li>Each variable forms a column.</li>
<li>Each observation forms a row.</li>
<li>Each type of observational unit forms a table.</li>
</ol>
<p>Because there is only one observational unit in the example (religions), it can be described in a single table. Large and complex datasets are usually represented by multiple tables, with unique identifiers or ‘keys’ to join them together <span class="citation">(Codd <a href="#ref-Codd1979">1979</a>)</span>.</p>
<p>Two common operations facilitated by <strong>tidyr</strong> are <em>gathering</em> and <em>splitting</em> columns, as illustrated below.</p>
<ul>
<li>‘Wide’ tables can become ‘long’, so that column names become a new variable. This is illustrated in Table @ref(tab:tpew) and Table @ref(tab:tpewt) and can be achieved with the function <code>gather</code>:<a href="#fn15" class="footnoteRef" id="fnref15"><sup>15</sup></a></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">raw =<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;data/pew.csv&quot;</span>) <span class="co"># read in the &#39;wide&#39; dataset</span>
<span class="kw">dim</span>(raw)</code></pre></div>
<pre><code>## [1] 18 10</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rawt =<span class="st"> </span><span class="kw">gather</span>(raw, Income, Count, -religion)
<span class="kw">dim</span>(rawt)</code></pre></div>
<pre><code>## [1] 162   3</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rawt[<span class="dv">1</span>:<span class="dv">3</span>,]</code></pre></div>
<pre><code>## Source: local data frame [3 x 3]
## 
##   religion Income Count
##      (chr)  (chr) (int)
## 1 Agnostic  &lt;$10k    27
## 2  Atheist  &lt;$10k    12
## 3 Buddhist  &lt;$10k    27</code></pre>
<ul>
<li>Splitting compound variables in two. A classic example is age-sex variables (e.g. <code>m0-10</code> and <code>f0-15</code> to represent males and females in the 0 to 10 age band). Splitting such variables can be done with <code>separate</code>, as illustrated in the difference between Table @ref(tab:to-separate) and @ref(tab:separated):</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">agesex =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;m0-10&quot;</span>, <span class="st">&quot;f0-10&quot;</span>) <span class="co"># create compound variable</span>
n =<span class="st"> </span><span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>) <span class="co"># create a value for each observation</span>
df =<span class="st"> </span><span class="kw">data.frame</span>(agesex, n) <span class="co"># create a data frame</span>
<span class="kw">separate</span>(df, agesex, <span class="kw">c</span>(<span class="st">&quot;sex&quot;</span>, <span class="st">&quot;age&quot;</span>), <span class="dv">1</span>)</code></pre></div>
<pre><code>##   sex  age n
## 1   m 0-10 3
## 2   f 0-10 5</code></pre>
<table>
<caption>(#tab:to-separate)Joined age and sex variables in one column</caption>
<thead>
<tr class="header">
<th align="left">agesex</th>
<th align="right">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">m0-10</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">f0-10</td>
<td align="right">5</td>
</tr>
</tbody>
</table>
<table>
<caption>(#tab:seperated)Age and sex variables separated by the funtion <code>separate</code>.</caption>
<thead>
<tr class="header">
<th align="left">sex</th>
<th align="left">age</th>
<th align="right">n</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">m</td>
<td align="left">0-10</td>
<td align="right">3</td>
</tr>
<tr class="even">
<td align="left">f</td>
<td align="left">0-10</td>
<td align="right">5</td>
</tr>
</tbody>
</table>
<p>There are other tidying operations that <strong>tidyr</strong> can perform, as described in the package’s vignette (<code>vignette(&quot;tidy-data&quot;)</code>). Data manipulation is a large topic with major potential implications for efficiency <span class="citation">(<span class="citeproc-not-found" data-reference-id="Spector2008"><strong>???</strong></span>)</span>.</p>
</div>
<div id="dplyr" class="section level2">
<h2><span class="header-section-number">5.5</span> Data processing</h2>
<p>Tidy data is easier to process than messy data. As with many aspects of R programming there are many ways to process a dataset, some more efficient than others. Following our own advice to decide appropriate packages for the work early on (see Section @ref(pkgs)) uses <strong>dplyr</strong>, which has a number of advantages compared with base R and <strong>data.table</strong>:</p>
<ul>
<li><strong>dplyr</strong> is fast to run and intuitive to type</li>
<li><strong>dplyr</strong> works well with tidy data, as described above</li>
<li><strong>dplyr</strong> works well with databases, providing efficiency gains on large datasets</li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;readr&quot;</span>)
fname &lt;-<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata/world-bank-ineq.csv&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;efficient&quot;</span>)
idata &lt;-<span class="st"> </span><span class="kw">read_csv</span>(fname)
idata <span class="co"># print the dataset in the **dplyr** way</span></code></pre></div>
<p><strong>dplyr</strong> is much faster than base implementations of various operations, but it has the potential to be even faster, as <em>parallelisation</em> is <a href="https://github.com/hadley/dplyr/issues/145">planned</a> and the <a href="https://github.com/hadley/multidplyr">multidplyr</a> package, a parallel backend for <strong>dplyr</strong>, is under development.</p>
<p>You should not be expecting to learn the <strong>dplyr</strong> package in one sitting: the package is large and can be seen as a language in its own right. Following the ‘walk before you run’ principle, we’ll start simple, by filtering and aggregating rows, building on the previous section on tidying data.</p>
<div id="renaming-columns" class="section level3">
<h3><span class="header-section-number">5.5.1</span> Renaming columns</h3>
<p>Renaming data columns is a common task that can make writing code faster by using short, intuitive names. The <strong>dplyr</strong> function <code>rename()</code> makes this easy.<a href="#fn16" class="footnoteRef" id="fnref16"><sup>16</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">idata =<span class="st"> </span><span class="kw">rename</span>(idata, <span class="dt">Country =</span> <span class="st">`</span><span class="dt">Country Name</span><span class="st">`</span>)</code></pre></div>
<p>To rename multiple columns the variable names are simply separated by commas. The base R and <strong>dplyr</strong> way of doing this is illustrated for clarity.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># The dplyr way (rename two variables)</span>
idata &lt;-<span class="st"> </span><span class="kw">rename</span>(idata,
 <span class="dt">top10 =</span> <span class="st">`</span><span class="dt">Income share held by highest 10% [SI.DST.10TH.10]</span><span class="st">`</span>,
 <span class="dt">bot10 =</span> <span class="st">`</span><span class="dt">Income share held by lowest 10% [SI.DST.FRST.10]</span><span class="st">`</span>)

<span class="co"># The base R way (rename five variables)</span>
<span class="kw">names</span>(idata)[<span class="dv">5</span>:<span class="dv">9</span>] =
<span class="st">  </span><span class="kw">c</span>(<span class="st">&quot;top10&quot;</span>, <span class="st">&quot;bot10&quot;</span>, <span class="st">&quot;gini&quot;</span>, <span class="st">&quot;b40_cons&quot;</span>, <span class="st">&quot;gdp_percap&quot;</span>)</code></pre></div>
<p>Now we have usefully renamed the object we save the result for future reference:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">saveRDS</span>(idata, <span class="st">&quot;data/idata-renamed.Rds&quot;</span>)</code></pre></div>
</div>
<div id="filtering-rows" class="section level3">
<h3><span class="header-section-number">5.5.2</span> Filtering rows</h3>
<p>The standard way to subset data by rows in R is with square brackets, for example:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aus1 =<span class="st"> </span>idata[idata$Country ==<span class="st"> &quot;Australia&quot;</span>,]</code></pre></div>
<p><strong>dplyr</strong> offers an alternative and more flexible way of filtering data, using <code>filter()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">aus2 =<span class="st"> </span><span class="kw">filter</span>(idata, Country ==<span class="st"> &quot;Australia&quot;</span>)</code></pre></div>
<p>Note that <strong>dplyr</strong> does not rely on the <code>$</code> symbol: it knows that that <code>Country</code> is a variable of <code>idata</code> Because <code>idata</code> was the first argument, <strong>dplyr</strong> assumes that any subsequent are variables.<a href="#fn17" class="footnoteRef" id="fnref17"><sup>17</sup></a></p>
<p>The <strong>dplyr</strong> equivalent of aggregate is to use the grouping function <code>group_by</code> in combination with the general purpose function <code>summarise</code> (not to be confused with <code>summary</code> in base R).</p>
</div>
<div id="filtering-columns" class="section level3">
<h3><span class="header-section-number">5.5.3</span> Filtering columns</h3>
<p>Large datasets often contain much worthless or blank information, clogging up RAM and reducing computational efficiency. Being able to focus quickly only on the variables of interest becomes especially important when handling large datasets.</p>
<p>Imagine that we have large (4+ GB) text file called <code>miniaa</code> which is loaded with the following command:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fname =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata/miniaa&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;efficient&quot;</span>)
df =<span class="st"> </span><span class="kw">read_csv</span>(fname) <span class="co"># load imaginary large data</span>
<span class="kw">dim</span>(df)</code></pre></div>
<pre><code>## [1]   9 329</code></pre>
<p>Note that the data frame has 329 columns (and imagine it has 4 million+ rows as the original does). That’s a lot of variables. Do we need them all? It’s worth taking a glimpse at this dataset to find out:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">glimpse</span>(df)</code></pre></div>
<pre><code># $ NPI                   (int) 1679576722, ...
# $ Entity Type Code      (int) 1, 1, 2,    ...
# $ Replacement NPI       (lgl) NA, NA, NA, ...
# ...</code></pre>
<p>Looking at the output, it becomes clear that the majority of the variables only contain <code>NA</code>. To clean the giant dataset, removing the empty columns, we need to identify which these variables are.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Identify the variable which are all NA</span>
all_na =<span class="st"> </span><span class="kw">sapply</span>(df, function(x) <span class="kw">all</span>(<span class="kw">is.na</span>(x)))
<span class="kw">summary</span>(all_na) <span class="co"># summary of the results</span></code></pre></div>
<pre><code>##    Mode   FALSE    NA&#39;s 
## logical     329       0</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">df =<span class="st"> </span>df[!all_na] <span class="co"># subset the dataframe</span></code></pre></div>
<p>The new <code>df</code> object has fewer than a third of the original columns.</p>
<blockquote>
<p><strong>Challenge:</strong> find out how much space was saved by the above operation using <code>object.size()</code></p>
</blockquote>
</div>
<div id="data-aggregation" class="section level3">
<h3><span class="header-section-number">5.5.4</span> Data aggregation</h3>
<p>Data aggregation is the process of creating summaries of data based on a grouping variable. The end result usually has the same number of rows as there are groups. Because aggregation is a way of condensing datasets it can be a very useful technique for making sense of large datasets. The following code finds the average emissions per country (country being the grouping variable) from the ‘GHG’ dataset rescued from a spreadsheet and converted into a .csv file in the previous chapter.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">fname =<span class="st"> </span><span class="kw">system.file</span>(<span class="st">&quot;extdata/ghg-ems.csv&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;efficient&quot;</span>)
df =<span class="st"> </span><span class="kw">read.csv</span>(fname)
<span class="kw">names</span>(df)</code></pre></div>
<pre><code>## [1] &quot;X&quot;                                       
## [2] &quot;Country&quot;                                 
## [3] &quot;Year&quot;                                    
## [4] &quot;Electricity.Heat..CO2...MtCO2.&quot;          
## [5] &quot;Manufacturing.Construction..CO2...MtCO2.&quot;
## [6] &quot;Transportation..CO2...MtCO2.&quot;            
## [7] &quot;Other.Fuel.Combustion..CO2...MtCO2.&quot;     
## [8] &quot;Fugitive.Emissions..CO2...MtCO2.&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">nrow</span>(df)</code></pre></div>
<pre><code>## [1] 7896</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">length</span>(<span class="kw">unique</span>(df$Country))</code></pre></div>
<pre><code>## [1] 188</code></pre>
<blockquote>
<p><strong>Challenge:</strong> rename the variables 4 to 8 so they are much shorter, following the pattern <code>ECO2</code>, <code>MCO2</code> etc. That will make the code for manipulating the dataset easier to write</p>
</blockquote>
<p>After the variable names have been updated, we can aggregate.<a href="#fn18" class="footnoteRef" id="fnref18"><sup>18</sup></a></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e_ems =<span class="st"> </span><span class="kw">aggregate</span>(df$ECO2, <span class="kw">list</span>(df$Country), mean, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>)
<span class="kw">nrow</span>(e_ems)</code></pre></div>
<pre><code>## [1] 188</code></pre>
<p>Note that the resulting data frame has the same number of rows as there are countries: the aggregation has successfully reduced the number of rows we need to deal with. Now it is easier to find out per-country statistics, such as the three lowest emitters from electricity production:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(e_ems[<span class="kw">order</span>(e_ems$x),], <span class="dv">3</span>)</code></pre></div>
<pre><code>##     Group.1          x
## 77  Iceland 0.01785714
## 121   Nepal 0.02333333
## 18    Benin 0.04642857</code></pre>
<p>Another way to specify the <code>by</code> argument is with the tilde (<code>~</code>). The following command creates the same object as <code>e_ems</code>, but with less typing.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">e_ems =<span class="st"> </span><span class="kw">aggregate</span>(ECO2 ~<span class="st"> </span>Country, df, mean, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>)</code></pre></div>
<p>To aggregate the dataset using <strong>dplyr</strong> package one would divide the task in two: to <em>group</em> the dataset first and then to summarise, as illustrated below:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;dplyr&quot;</span>)
<span class="kw">group_by</span>(df, Country) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">mean_eco2 =</span> <span class="kw">mean</span>(ECO2, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code>## Source: local data frame [188 x 2]
## 
##              Country   mean_eco2
##               (fctr)       (dbl)
## 1        Afghanistan         NaN
## 2            Albania   0.6411905
## 3            Algeria  23.0147619
## 4             Angola   0.7914286
## 5  Antigua &amp; Barbuda         NaN
## 6          Argentina  39.1054762
## 7            Armenia   1.8000000
## 8          Australia 150.5961905
## 9            Austria  17.3202381
## 10        Azerbaijan  16.0430435
## ..               ...         ...</code></pre>
</div>
</div>
<div id="updating-column-classes" class="section level2">
<h2><span class="header-section-number">5.6</span> Updating column classes</h2>
<p>The <em>class</em> of R objects is critical to how it performs. If a class is incorrectly specified (if numbers are treated as factors, for example), R will likely generate error messages. Try typing <code>mean(idata$gini)</code>, for example.</p>
<p>We can re-assign the classes of the numeric variables one-by one:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">idata$gini =<span class="st"> </span><span class="kw">as.numeric</span>(idata$gini)</code></pre></div>
<pre><code>## Warning: NAs introduced by coercion</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">mean</span>(idata$gini, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>) <span class="co"># now the mean is calculated</span></code></pre></div>
<pre><code>## [1] 40.50363</code></pre>
<p>However, the purpose of programming languages is to <em>automate</em> arduous tasks and reduce typing. The following command re-classifies all of the numeric variables using the <code>apply</code> function (we’ll seem more of <code>apply</code>’s relatives later):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">idata[<span class="dv">5</span>:<span class="dv">9</span>] =<span class="st"> </span><span class="kw">apply</span>(idata[<span class="dv">5</span>:<span class="dv">9</span>], <span class="dv">2</span>,
  function(x) <span class="kw">as.numeric</span>(x))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">countries =<span class="st"> </span><span class="kw">group_by</span>(idata, Country)
<span class="kw">summarise</span>(countries, <span class="dt">gini =</span> <span class="kw">mean</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>))</code></pre></div>
<pre><code>## Source: local data frame [176 x 2]
## 
##         Country     gini
##           (chr)    (dbl)
## 1   Afghanistan      NaN
## 2       Albania 30.43167
## 3       Algeria 37.76000
## 4        Angola 50.65000
## 5     Argentina 48.06739
## 6       Armenia 33.72929
## 7     Australia 33.14167
## 8       Austria 29.15167
## 9    Azerbaijan 24.79000
## 10 Bahamas, The      NaN
## ..          ...      ...</code></pre>
<p>Note that <code>summarise</code> is highly versatile, and can be used to return a customised range of summary statistics:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summarise</span>(countries,
  <span class="co"># number of rows per country</span>
  <span class="dt">obs =</span> <span class="kw">n</span>(), 
  <span class="dt">med_t10 =</span> <span class="kw">median</span>(top10, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>),
  <span class="co"># standard deviation</span>
  <span class="dt">sdev =</span> <span class="kw">sd</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>), 
  <span class="co"># number with gini &gt; 30</span>
  <span class="dt">n30 =</span> <span class="kw">sum</span>(gini &gt;<span class="st"> </span><span class="dv">30</span>, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>), 
  <span class="dt">sdn30 =</span> <span class="kw">sd</span>(gini[ gini &gt;<span class="st"> </span><span class="dv">30</span> ], <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>),
  <span class="co"># range</span>
  <span class="dt">dif =</span> <span class="kw">max</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>) -<span class="st"> </span><span class="kw">min</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>)
  )</code></pre></div>
<pre><code>## Source: local data frame [176 x 7]
## 
##         Country   obs med_t10      sdev   n30      sdn30   dif
##           (chr) (int)   (dbl)     (dbl) (int)      (dbl) (dbl)
## 1   Afghanistan    40      NA       NaN     0         NA    NA
## 2       Albania    40  24.435  1.252524     3  0.3642801  2.78
## 3       Algeria    40  29.780  3.436539     2  3.4365390  4.86
## 4        Angola    40  38.555 11.299566     2 11.2995664 15.98
## 5     Argentina    40  36.320  3.182462    23  3.1824622 11.00
## 6       Armenia    40  27.835  4.019532    12  3.9567778 14.84
## 7     Australia    40  24.785  1.075089     6  1.0750891  2.81
## 8       Austria    40  23.120  3.120849     4  0.6859300  8.48
## 9    Azerbaijan    40  17.960  9.479029     3  1.7386489 20.27
## 10 Bahamas, The    40      NA       NaN     0         NA    NA
## ..          ...   ...     ...       ...   ...        ...   ...</code></pre>
<p>To showcase the power of <code>summarise</code> used on a <code>grouped_df</code>, the above code reports a wide range of customised summary statistics <em>per country</em>:</p>
<ul>
<li>the number of rows in each country group</li>
<li>standard deviation of gini indices</li>
<li>median proportion of income earned by the top 10%</li>
<li>the number of years in which the gini index was greater than 30</li>
<li>the standard deviation of gini index values over 30</li>
<li>the range of gini index values reported for each country.</li>
</ul>
<blockquote>
<p><strong>Challenge</strong>: explore the <strong>dplyr</strong>’s documentation, starting with the introductory vignette, accessed by entering <code>vignette(&quot;introduction&quot;)</code> and test out its capabilities on the <code>idata</code> dataset. (More vignette names can be discovered by typing <code>vignette(package = &quot;dplyr&quot;)</code>)</p>
</blockquote>
<div id="chaining-operations-with-dplyr" class="section level3">
<h3><span class="header-section-number">5.6.1</span> Chaining operations with <strong>dplyr</strong></h3>
<p>Another interesting feature of <strong>dplyr</strong> is its ability to chain operations together. This overcomes one of the aesthetic issues with R code: you can end end-up with very long commands with many functions nested inside each other to answer relatively simple questions.</p>
<blockquote>
<p>What were, on average, the 5 most unequal years for countries containing the letter g?</p>
</blockquote>
<p>Here’s how chains work to organise the analysis in a logical step-by-step manner:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">idata %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(<span class="kw">grepl</span>(<span class="st">&quot;g&quot;</span>, Country)) %&gt;%
<span class="st">  </span><span class="kw">group_by</span>(Year) %&gt;%
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">gini =</span> <span class="kw">mean</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>)) %&gt;%
<span class="st">  </span><span class="kw">arrange</span>(<span class="kw">desc</span>(gini)) %&gt;%
<span class="st">  </span><span class="kw">top_n</span>(<span class="dt">n =</span> <span class="dv">5</span>)</code></pre></div>
<pre><code>## Selecting by gini</code></pre>
<pre><code>## Source: local data frame [5 x 2]
## 
##    Year   gini
##   (int)  (dbl)
## 1  1980 46.850
## 2  1993 45.996
## 3  2013 44.550
## 4  1981 43.650
## 5  2012 43.560</code></pre>
<p>The above function consists of 6 stages, each of which corresponds to a new line and <strong>dplyr</strong> function:</p>
<ol style="list-style-type: decimal">
<li>Filter-out the countries we’re interested in (any selection criteria could be used in place of <code>grepl(&quot;g&quot;, Country)</code>).</li>
<li>Group the output by year.</li>
<li>Summarise, for each year, the mean gini index.</li>
<li>Arrange the results by average gini index</li>
<li>Select only the top 5 most unequal years.</li>
</ol>
<p>To see why this method is preferable to the nested function approach, take a look at the latter. Even after indenting properly it looks terrible and is almost impossible to understand!</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">top_n</span>(
  <span class="kw">arrange</span>(
    <span class="kw">summarise</span>(
      <span class="kw">group_by</span>(
        <span class="kw">filter</span>(idata, <span class="kw">grepl</span>(<span class="st">&quot;g&quot;</span>, Country)),
        Year),
      <span class="dt">gini =</span> <span class="kw">mean</span>(gini, <span class="dt">na.rm  =</span> <span class="ot">TRUE</span>)),
    <span class="kw">desc</span>(gini)),
  <span class="dt">n =</span> <span class="dv">5</span>)</code></pre></div>
<p>This section has provided only a taster of what is possible <strong>dplyr</strong> and why it makes sense from code writing and computational efficiency perspectives. For a more detailed account of data processing with R using this approach we recommend <em>R for Data Science</em> <span class="citation">(Grolemund and Wickham <a href="#ref-grolemund_r_2016">2016</a>)</span>.</p>
</div>
<div id="data.table" class="section level3">
<h3><span class="header-section-number">5.6.2</span> <strong>data.table</strong></h3>
<p><strong>data.table</strong> is a mature package for fast data processing that presents an alternative to <strong>dplyr</strong>. There is some controversy about which is more appropriate for different tasks<a href="#fn19" class="footnoteRef" id="fnref19"><sup>19</sup></a> so it should be stated at the outset that <strong>dplyr</strong> and <strong>data.table</strong> are not mutually exclusive competitors or that must be ‘better’ than another. These are both excellent packages and the important thing from an efficiency perspective is that they can help speed up data processing tasks.</p>
<p><strong>data.table</strong> does have some unique features that make it very fast at accomplishing some tasks very efficiently that it is worth being aware of, however. Building on the <code>filter()</code> example above, we’ll see <strong>data.tables</strong>’s unique approach to subsetting.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(data.table)
idata =<span class="st"> </span><span class="kw">readRDS</span>(<span class="st">&quot;data/idata-renamed.Rds&quot;</span>)
idata_dt =<span class="st"> </span><span class="kw">data.table</span>(idata)
<span class="kw">setkey</span>(idata_dt, Country)
aus3 =<span class="st"> </span>idata_dt[<span class="st">&quot;Australia&quot;</span>,]</code></pre></div>
<div class="figure">
<img src="_main_files/figure-html/dtplot-1.png" alt="(\#fig:dtplot)Benchmark illustrating the performance gains to be expected for different dataset sizes."  />
<p class="caption">
(#fig:dtplot)Benchmark illustrating the performance gains to be expected for different dataset sizes.
</p>
</div>
<p>Figure @ref(fig:dtplot) illustrates the speed improvement benefits of data.table for different datasets sizes. As with the <strong>readr</strong> vs base R issue, the results show that the relative benefits of <strong>data.table</strong> improve with dataset size.</p>
</div>
</div>
<div id="publication" class="section level2">
<h2><span class="header-section-number">5.7</span> Publication</h2>
<!-- Thought: this should be more about 'getting your work out there' than packages-->
<p>This section describes a strict approach to project management and workflow: treating your projects as R packages. This is good practice in terms of learning to correctly document your code, store example data, and even (via vignettes) ensure reproducibility. This approach to R workflow is appropriate for managing complex projects and should provide a strong foundation for generalising your code for use by others.</p>
<!--chapter:end:04-workflow.Rmd-->
</div>
</div>
<div id="efficient-collaboration" class="section level1">
<h1><span class="header-section-number">6</span> Efficient collaboration</h1>
<!--chapter:end:05-collaboration.Rmd-->
</div>
<div id="efficient-programming" class="section level1">
<h1><span class="header-section-number">7</span> Efficient programming</h1>
<!--# Efficient programming  {#programming}-->
<p>In this chapter we will discuss key R data types and idiomatic programming style. Many people that use R would not describe themselves as “programmers”. Instead, they have advanced domain level knowledge, but little formal training in programming. This chapter comes from their point of view; someone who has use standard R data structures, such as vectors and data frames, but has never looked as the inner workings of these objects.</p>
<p>We begin this chapter by discussing key data types, how they are used and potential computational gains available. Once we understand these objects, we will look at key R programming idioms, before covering techniques for speeding up code.</p>
<div id="data-types" class="section level2">
<h2><span class="header-section-number">7.1</span> Data types</h2>
<p>A data type is an object that has a set of predefined characteristics, such as a number or a character. When programming in C or FORTRAN, the data type of every object must be specified by the user. he advantage is that it allows the compiler to perform type-specific optimisation. The downside is verbose and fragile code, which is inefficient to type. In R data types are less critical, but understanding them will help you debug and optimize for computational efficiency. Essentially, we have a trade-off between CPU run time and developer thinking time. However an understanding of data types can help when debugging and optimizing for computational efficiency. In this chapter, we will pick out the key point data types from an efficiency perspective. Chapter 2 of Advanced R Programming <span class="citation">(Wickham <a href="#ref-Wickham2014">2014</a><a href="#ref-Wickham2014">a</a>)</span> provides a more comprehensive treatment.</p>
<div id="vectors" class="section level3">
<h3><span class="header-section-number">7.1.1</span> Vectors</h3>
<p>The vector is a fundamental data structure in R. Confusingly there are two varieties:</p>
<ul>
<li>Atomic vectors are where all elements have the same type and are usually created using the <code>c()</code> function;</li>
<li>Lists are where elements can have different types.</li>
</ul>
<p>To test if an object is a vector, we must use <code>is.atomic(x) || is.list(x)</code>. The more obvious choice for determining if an object is a vector, <code>is.vector(x)</code>, only returns <code>TRUE</code> is an object is a vector with no attributes other than names. For example, when we use the <code>table</code> function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="kw">table</span>(<span class="kw">rpois</span>(<span class="dv">100</span>, <span class="dv">5</span>))</code></pre></div>
<p>the object <code>x</code> has additional attributes (such as <code>dim</code>), so <code>is.vector(x)</code> return <code>FALSE</code>. But the contents <code>x</code> is clearly a vector, so <code>is.atomic(x)</code> returns <code>TRUE</code>.</p>
<p>The core vector data types are logicals, integers, doubles and characters. When an atomic vector is created with a mixture of types, the output type is coerced to highest type in the following hierarchy:</p>
<pre><code>logical &lt; integer &lt; double &lt; character </code></pre>
<p>This means that any vector containing a character string will be coerced to class, as illustrated below.</p>
<div id="numerics-doubles-and-integers" class="section level4">
<h4><span class="header-section-number">7.1.1.1</span> Numerics: doubles and integers</h4>
<p>Numbers in R are usually stored in <a href="https://goo.gl/ZA5R8a">double-precision floating-point format</a> - see <span class="citation">Braun and Murdoch (<a href="#ref-Braun2007">2007</a>)</span> and <span class="citation">Goldberg (<a href="#ref-Goldberg1991">1991</a>)</span>. The term ‘double’ refers to the fact that on <span class="math inline">\(32\)</span> bit systems (for which the format was developed) two memory locations are used to store a single number. Each double-precision number occupies <span class="math inline">\(8\)</span> bytes and is accurate to around <span class="math inline">\(17\)</span> decimal places (R does not print all of these, as you will see by typing <code>pi</code>). Somewhat surprisingly, when we run the command</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>we have created an atomic vector, contain a single double-precision floating point number. When comparing floating point numbers, we should be particularly careful, since</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">y =<span class="st"> </span><span class="kw">sqrt</span>(<span class="dv">2</span>)*<span class="kw">sqrt</span>(<span class="dv">2</span>)
y ==<span class="st"> </span><span class="dv">2</span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<p>This is because the value of <code>y</code> is not exactly <span class="math inline">\(2\)</span>, instead it’s <strong>almost</strong> <span class="math inline">\(2\)</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sprintf</span>(<span class="st">&quot;%.16f&quot;</span>, y)</code></pre></div>
<pre><code>## [1] &quot;2.0000000000000004&quot;</code></pre>
<p>To compare numbers in R it is advisable to use <code>all.equal</code> and set an appropriate tolerance, e.g.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">all.equal</span>(y, <span class="dv">2</span>, <span class="dt">tolerance =</span> <span class="fl">1e-9</span>)</code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Although using double precision objects is the most common type, R does have other ways of storing numbers:</p>
<ul>
<li><p><code>single</code>: R doesn’t have a single precision data type. Instead, all real numbers are stored in double precision format. The functions <code>as.single</code> and <code>single</code> are identical to <code>as.double</code> and <code>double</code> except they set the attribute <code>Csingle</code> that is used in the <code>.C</code> and <code>.Fortran</code> interface.</p></li>
<li><p><code>integer</code>: Integers primarily exist to be passed to C or Fortran code. Typically we don’t worry about creating integers. However they are occasionally used to optimise sub-setting operations. When we subset a data frame or matrix, we are interacting with C code. For example, if we look at the arguments for the <code>head</code> function</p></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">args</span>(head.matrix)</code></pre></div>
<pre><code>## function (x, n = 6L, ...) 
## NULL</code></pre>
<p>The default argument is <code>6L</code> (the <code>L</code>, is short for Literal and is used to create an integer). Since this function is being called by almost everyone that uses R, this low level optimisation is useful. To illustrate the speed increase, suppose we are selecting the first <span class="math inline">\(100\)</span> rows from a data frame (<code>clock_speed</code>, from the <strong>efficient</strong> package). The speed increase is illustrated below, using the <strong>microbenchmark</strong> package:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">s_int =<span class="st"> </span><span class="dv">1</span>:<span class="dv">100</span>; s =<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>, <span class="dv">100</span>, <span class="fl">1.0</span>)
<span class="kw">microbenchmark</span>(clock_speed[s_int, 2L], clock_speed[s, <span class="fl">2.0</span>], <span class="dt">times=</span>1000000L)</code></pre></div>
<pre><code>## Unit: microseconds
## expr   min    lq  mean median    uq   max neval cld
## clock_speed[s_int, 2L] 11.79 13.43 15.30  13.81 14.22 87979 1e+06  a 
## clock_speed[s, 2] 12.79 14.37 16.04  14.76 15.18 21964 1e+06   b</code></pre>
<p>The above result shows that using integers is slightly faster, but probably not worth worrying about.</p>
<ul>
<li><code>numeric</code>: The function <code>numeric()</code> is identical to <code>double()</code>; it creates is a double-precision number. However, <code>is.numeric()</code> isn’t the same as <code>as.double()</code>, instead <code>is.numeric()</code> returns <code>TRUE</code> for both numeric and double types.</li>
</ul>
<p>To find out the type of data stored in an R vector use the command <code>typeof()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">typeof</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>))</code></pre></div>
<pre><code>## [1] &quot;character&quot;</code></pre>
</div>
<div id="exercises-9" class="section level4">
<h4><span class="header-section-number">7.1.1.2</span> Exercises</h4>
<p>A good way of determining how to use more advanced programming concepts, is to examine the source code of R.</p>
<ol style="list-style-type: decimal">
<li>What are the data types of <code>c(1, 2, 3)</code> and <code>1:3</code>?</li>
<li>Have a look at the following function definitions:
<ul>
<li><code>tail.matrix</code></li>
<li><code>lm</code></li>
</ul></li>
<li>How does the function <code>seq.int</code>, which was used in the <code>tail.matrix</code> function, differ to the standard <code>seq</code> function?</li>
</ol>
</div>
</div>
<div id="factors" class="section level3">
<h3><span class="header-section-number">7.1.2</span> Factors</h3>
<p>A factor is useful when you know all of the possible values a variable may take. For example, suppose our data set related to months of the year</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;January&quot;</span>, <span class="st">&quot;December&quot;</span>, <span class="st">&quot;March&quot;</span>)</code></pre></div>
<p>If we sort <code>m</code> in the usual way <code>sort(m)</code>, we use standard alpha-numeric ordering, placing December first. While this is completely correct, it is also not that helpful. We can use factors to remedy this problem by specifying the admissible levels</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## month.name contains the 12 months
fac_m =<span class="st"> </span><span class="kw">factor</span>(m, <span class="dt">levels=</span>month.name)
<span class="kw">sort</span>(fac_m)</code></pre></div>
<pre><code>## [1] January  March    December
## 12 Levels: January February March April May June July August ... December</code></pre>
<p>Most users interact with factors via the <code>read.csv</code> function where character columns are automatically converted to factors. It is generally recommended to avoid this feature using the <code>stringsAsFactors=FALSE</code> argument. Although this argument can be also placed in the global <code>options()</code> list, this leads to non-portable code, so should be avoided.</p>
<p>Although factors look similar to character vectors, they are actually integers. This leads to initially surprising behaviour</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(m)</code></pre></div>
<pre><code>## [1] &quot;January&quot;  &quot;December&quot; &quot;March&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">c</span>(fac_m)</code></pre></div>
<pre><code>## [1]  1 12  3</code></pre>
<p>In this case the <code>c()</code> function is using the underlying integer representation of the factor. Overall factors are useful, but can lead to unwanted side-effects if we are not careful.</p>
<p>In early versions of R, storing character data as a factor was more space efficient. However since identical character strings now share storage, the space gain in factors is now space.</p>
</div>
<div id="data-frames" class="section level3">
<h3><span class="header-section-number">7.1.3</span> Data frames</h3>
<p>A data frame is a tabular (two dimensional or ‘rectangular’) object in which the columns may be composed of differing vector types such as <code>numeric</code>, <code>logical</code>, <code>character</code> and so on. Matrices can only accept a single data type for all cells as explained in the next section. Data frames are the workhorses of R. Many R functions, such as <code>boxplot</code>, <code>lm</code> and <code>ggplot</code>, expect your data set to be in a data frame. As a general rule, columns in your data should be variables and rows should be the thing of interest. This is illustrated in the <code>USAarrests</code> data set:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(USArrests, <span class="dv">2</span>)</code></pre></div>
<pre><code>##         Murder Assault UrbanPop Rape
## Alabama   13.2     236       58 21.2
## Alaska    10.0     263       48 44.5</code></pre>
<p>Note that each row corresponds to a particular state and each column to a variable. One particular trap to be wary of is when using <code>read.csv</code> and <code>read.table</code> characters are automatically converted to factors. One can avoid this pitfall by using the argument <code>stringsAsFactors = FALSE</code>.</p>
<p>Since working with R frequently involves interacting with data frames, it’s useful to be fluent a few key functions:</p>
<table>
<caption>Useful data frame functions.</caption>
<thead>
<tr class="header">
<th align="left">Name</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><code>dim</code></td>
<td align="left">Data frame dimensions</td>
</tr>
<tr class="even">
<td align="left"><code>ncol</code>/<code>nrow</code></td>
<td align="left">No. of columns/rows</td>
</tr>
<tr class="odd">
<td align="left"><code>NCOL</code>/<code>NROW</code></td>
<td align="left">As above, but also works with vectors</td>
</tr>
<tr class="even">
<td align="left"><code>cbind</code>/<code>rbind</code></td>
<td align="left">Column/row bind</td>
</tr>
<tr class="odd">
<td align="left"><code>head</code>/<code>tail</code></td>
<td align="left">Select the first/last few rows</td>
</tr>
<tr class="even">
<td align="left"><code>colnames</code>/<code>rownames</code></td>
<td align="left">Column and row</td>
</tr>
</tbody>
</table>
<p>When loading a dataset called <code>df</code> into R, a typical workflow would be:</p>
<ul>
<li>Check dimensions using <code>dim(df)</code>;</li>
<li>Look at the first/last few rows using <code>head(df)</code> and <code>tail(df)</code>;</li>
<li>Rename columns using <code>colnames(df) =</code>.</li>
</ul>
</div>
<div id="matrix" class="section level3">
<h3><span class="header-section-number">7.1.4</span> Matrix</h3>
<p>A matrix is similar to a data frame: it is a two dimensional object and sub-setting and other functions work in the same way. However all matrix columns must have the same type. Matrices tend to be used during statistical calculations. Linear regression using <code>lm()</code>, for example, internally converts the data to a matrix before calculating the results; any characters are thus recoded as numeric dummy variables.</p>
<p>Matrices are generally faster than data frames. The datasets <code>ex_mat</code> and <code>ex_df</code> from the <strong>efficient</strong> package each have <span class="math inline">\(1000\)</span> rows and <span class="math inline">\(100\)</span> columns. They contain the same random numbers. However, selecting rows from a data frame is around <span class="math inline">\(150\)</span> times slower than a matrix. This illustrates the reason for using matrices instead of data frames for efficient modelling in R:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(ex_mat, ex_df, <span class="dt">package=</span><span class="st">&quot;efficient&quot;</span>)
<span class="kw">benchmark</span>(<span class="dt">replications=</span><span class="dv">10000</span>, 
          ex_mat[<span class="dv">1</span>,], ex_df[<span class="dv">1</span>,], 
          <span class="dt">columns=</span><span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;elapsed&quot;</span>, <span class="st">&quot;relative&quot;</span>))</code></pre></div>
<pre><code>##          test elapsed relative
## 2  ex_df[1, ]   5.372  145.189
## 1 ex_mat[1, ]   0.037    1.000</code></pre>
</div>
<div id="S3" class="section level3">
<h3><span class="header-section-number">7.1.5</span> S3 objects</h3>
<p>R has three built-in object oriented systems. These systems differ in how classes and methods are defined. The easiest and oldest system is the S3 system. S3 refers to the third version of S. The syntax of R is largely based on this version of S. In R there has never been S1 and S2 classes.</p>
<p>The S3 system implements a generic-function object oriented (OO) system. This type of OO is different to the message-passing style of Java and C++. In a message-passing framework, messages/methods are sent to objects and the object determines which function to call, e.g. <code>normal.rand(1)</code>. The S3 class system is different. In S3, the generic function decides which method to call - it would have the form <code>rand(normal, 1)</code>.</p>
<p>The S3 system is based on the class of an object. In this system, a class is just an attribute. The S3 class(es) of a object can be determined with the <code>class</code> function.</p>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>The S3 system can be used to great effect. For example, a <code>data.frame</code> is simply a standard R list, with class <code>data.frame</code>. When we pass an object to a <em>generic</em> function, the function first examines the class of the object, and then decides what to do: it dispatches to another method. The generic <code>summary</code> function, for example, contains the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">summary</code></pre></div>
<pre><code>## function (object, ...) 
## UseMethod(&quot;summary&quot;)
## &lt;bytecode: 0x509cf38&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>Note that the only operational line is <code>UseMethod(&quot;summary&quot;)</code>. This handles the method dispatch based on the object’s class. So when <code>summary(USArrests)</code> is executed, the generic <code>summary</code> function passes <code>USArrests</code> to the function <code>summary.data.frame</code>.</p>
<p>This simple mechanism enables us to quickly create our own functions. Consider the distance object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dist_usa =<span class="st"> </span><span class="kw">dist</span>(USArrests)</code></pre></div>
<p><code>dist_usa</code> has class <code>dist</code>. To visualise the distances, we can create an image method. First we’ll check if the existing <code>image</code> function is generic, via</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">image</code></pre></div>
<pre><code>## function (x, ...) 
## UseMethod(&quot;image&quot;)
## &lt;bytecode: 0x5eeb1f0&gt;
## &lt;environment: namespace:graphics&gt;</code></pre>
<p>Since <code>image</code> is already a generic method, we just have to create a specific <code>dist</code> method</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">image.dist =<span class="st"> </span>function(x, ...) {
  x_mat =<span class="st"> </span><span class="kw">as.matrix</span>(x)
  <span class="kw">image</span>(x_mat, <span class="dt">main=</span><span class="kw">attr</span>(x, <span class="st">&quot;method&quot;</span>), ...)  
}</code></pre></div>
<p>The <code>...</code> argument allows us to pass arguments to the main image method, such as <code>axes</code> (see figure @ref(fig:6-1).</p>
<div class="figure" style="text-align: center">
<img src="_main_files/figure-html/6-1-1.png" alt="(\#fig:6-1)S3 image method for data of class `dist`."  />
<p class="caption">
(#fig:6-1)S3 image method for data of class <code>dist</code>.
</p>
</div>
<p>Many S3 methods work in the same way as the simple <code>image.dist</code> function created above: the object is converted into a standard format, then passed to the standard method. Creating S3 methods for standard functions such as <code>summary</code>, <code>mean</code>, and <code>plot</code> provides a nice uniform interface to a wide variety of data types.</p>
<div id="exercises-10" class="section level4">
<h4><span class="header-section-number">7.1.5.1</span> Exercises</h4>
<ol style="list-style-type: decimal">
<li>Use a combination of <code>unclass</code> and <code>str</code> on a data frame to confirm that it is a list.</li>
<li>Use the function <code>length</code> on a data frame. What is return? Why?</li>
</ol>
</div>
</div>
<div id="efficient-data-structures" class="section level3">
<h3><span class="header-section-number">7.1.6</span> Efficient data structures</h3>
<p>Even when our data set is small, the analysis can generate large objects. For example suppose we want to perform standard cluster analysis. Using the built-in data set <code>USAarrests</code>, we calculate a distance matrix:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dist_usa =<span class="st"> </span><span class="kw">dist</span>(USArrests)</code></pre></div>
<p>The resulting object <code>dist_usa</code> measures the similarity between two states with respect to the input data. Since there are <span class="math inline">\(50\)</span> states in the <code>USAarrests</code> data set, this results in a matrix with <span class="math inline">\(50\)</span> columns and <span class="math inline">\(50\)</span> rows. Intuitively, since the matrix <code>dist_usa</code> is symmetric around the diagonal, it makes sense to exploit this characteristic for efficiency, allowing storage to be halved. If we examine the object <code>dist_usa</code>, with <code>str(dist_usa)</code>, it becomes apparent that the data is efficiently stored as a vector with some attributes.</p>
<p>Another efficient data structure is a sparse matrix. This is simply a matrix in where most of the elements are zero. Conversely, if most elements are non-zero, the matrix is considered dense. The proportion of non-zero elements is called the sparsity. Large sparse matrices often crop up when performing numerical calculations. Typically, our data isn’t sparse but the resulting data structures we create may be sparse. There are a number of techniques/methods used to store sparse matrices. Methods for creating sparse matrices can be found in the <strong>Matrix</strong> package. For this <code>dist</code> object, since the structure is regular.</p>
</div>
</div>
<div id="good-programming-techniques" class="section level2">
<h2><span class="header-section-number">7.2</span> Good programming techniques</h2>
<p>A major benefit of using R (as opposed to C or Fortran, say), is that coding time is greatly reduced. However if we are not careful, it’s very easy to write programs that are incredibly slow. While optimisations such as going parallel can easily double speed, poor code can easily run 100s of times slower. For this reason a priority of an efficient programmer should be to avoid the following common mistakes. If you spend any time programming in R, then reading <span class="citation">(Burns <a href="#ref-Burns2011">2011</a>)</span> should be considered essential reading.</p>
<div id="general-tips" class="section level3">
<h3><span class="header-section-number">7.2.1</span> General tips</h3>
<p>The key to making R code run fast is to access the underlying C/Fortran routines as quickly as possible. For example, suppose that <code>x</code> is a standard R vector of length <code>n</code>. Then</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span>x +<span class="st"> </span><span class="dv">1</span></code></pre></div>
<p>involves a single function call to the <code>+</code> function. Whereas,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">for(i in <span class="dv">1</span>:n) {
  x[i] =<span class="st"> </span>x[i] +<span class="st"> </span><span class="dv">1</span> 
}</code></pre></div>
<p>has</p>
<ul>
<li><code>n</code> function calls to <code>+</code>;</li>
<li><code>n</code> function calls to the <code>[</code> function;</li>
<li><code>n</code> function calls to the <code>[&lt;-</code> function (used in the assignment operation);</li>
<li>A function call to <code>for</code> and the <code>:</code> operator.</li>
</ul>
<p>It isn’t that the <code>for</code> loop is slow, rather it is because we calling many more functions. This point is indirectly tackled again in the section on vectorised code.</p>
<p>Another general technique is to be careful with memory allocation. In fact this could be considered the number <span class="math inline">\(1\)</span> rule when programming in R. If possible always pre-allocate your vector or data frame then fill in the values. Let’s consider three methods of creating a sequence of numbers.</p>
<p><strong>Method 1</strong> creates an empty vector, and grows the object</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">method1 =<span class="st"> </span>function(n) {
  myvec =<span class="st"> </span><span class="ot">NULL</span>
  for(i in <span class="dv">1</span>:n)
    myvec =<span class="st"> </span><span class="kw">c</span>(myvec, i)
  myvec
}</code></pre></div>
<p><strong>Method 2</strong> creates an object of the final length and then changes the values in the object by subscripting:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">method2 =<span class="st"> </span>function(n) {
  myvec =<span class="st"> </span><span class="kw">numeric</span>(n)
  for(i in <span class="dv">1</span>:n)
    myvec[i] =<span class="st"> </span>i
  myvec
}</code></pre></div>
<p><strong>Method 3</strong> directly creates the final object</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">method3 =<span class="st"> </span>function(n) <span class="dv">1</span>:n</code></pre></div>
<p>To compare the three methods we use the <code>benchmark</code> function from the previous chapter</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n =<span class="st"> </span><span class="fl">1e4</span>
<span class="kw">benchmark</span>(<span class="dt">replications=</span><span class="dv">10</span>, 
          <span class="kw">method1</span>(n), <span class="kw">method2</span>(n), <span class="kw">method3</span>(n),
          <span class="dt">columns=</span><span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;elapsed&quot;</span>))</code></pre></div>
<pre><code>##         test elapsed
## 1 method1(n)   1.284
## 2 method2(n)   0.069
## 3 method3(n)   0.000</code></pre>
<p>The table below shows the timing in seconds on my machine for these three methods for a selection of values of <span class="math inline">\(n\)</span>. The relationships for varying <span class="math inline">\(n\)</span> are all roughly linear on a log-log scale, but the timings between methods are drastically different. Notice that the timings are no longer trivial. When <span class="math inline">\(n=10^7\)</span>, method 1 takes around an hour whilst method 2 takes <span class="math inline">\(2\)</span> seconds and method 3 is almost instantaneous.</p>
<table>
<caption>Time in seconds to create sequences. When <span class="math inline">\(n=10^7\)</span>, method 1 takes around an hour while methods 2 takes 2 seconds and method 3 almost instantaneous.</caption>
<thead>
<tr class="header">
<th align="left"><span class="math inline">\(n\)</span></th>
<th align="left">Method 1</th>
<th align="left">Method 2</th>
<th align="left">Method 3</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><span class="math inline">\(10^5\)</span></td>
<td align="left"><span class="math inline">\(\phantom{000}0.208\)</span></td>
<td align="left"><span class="math inline">\(0.024\)</span></td>
<td align="left"><span class="math inline">\(0.000\)</span></td>
</tr>
<tr class="even">
<td align="left"><span class="math inline">\(10^6\)</span></td>
<td align="left"><span class="math inline">\(\phantom{00}25.500\)</span></td>
<td align="left"><span class="math inline">\(0.220\)</span></td>
<td align="left"><span class="math inline">\(0.000\)</span></td>
</tr>
<tr class="odd">
<td align="left"><span class="math inline">\(10^7\)</span></td>
<td align="left"><span class="math inline">\(3827.0000\)</span></td>
<td align="left"><span class="math inline">\(2.212\)</span></td>
<td align="left"><span class="math inline">\(0.000\)</span></td>
</tr>
</tbody>
</table>
</div>
<div id="caching-variables" class="section level3">
<h3><span class="header-section-number">7.2.2</span> Caching variables</h3>
<p>A straightforward method for speeding up code is to calculate objects once and reuse the value when necessary. This could be as simple with replacing <code>log(x)</code> in multiple function calls with the object <code>log_x</code> that is defined once and reused. This small saving in time, quickly multiplies when the cached variable is used inside a <code>for</code> loop.</p>
<p>A more advanced form of caching is use the <strong>memoise</strong> package. If a function is called multiple times with the same input, it may be possible to speed things up by keeping a cache of known answers that it can retrieve. The <strong>memoise</strong> package allows us easily store the value of function call and returns the cached result when the function is called again with the same arguments. This package trades off memory versus speed, since the memoised function stores all previous inputs and outputs. To cache a function, we simply pass the function to the <strong>memoise</strong> function.</p>
<p>The classic memoise example is the factorial function. Another example is to limit use to a web resource. For example, suppose we are developing a shiny (an interactive graphic) application where the user can fit regression line to data. The user can remove points and refit the line. An example function would be</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Argument indicates row to remove
plot_mpg =<span class="st"> </span>function(row_to_remove) {
  <span class="kw">data</span>(mpg, <span class="dt">package=</span><span class="st">&quot;ggplot2&quot;</span>)
  mpg =<span class="st"> </span>mpg[-row_to_remove,]
  <span class="kw">plot</span>(mpg$cty, mpg$hwy)
  <span class="kw">lines</span>(<span class="kw">lowess</span>(mpg$cty, mpg$hwy), <span class="dt">col=</span><span class="dv">2</span>)
}</code></pre></div>
<p>We can use <strong>memoise</strong> speed up by caching results. A quick benchmark</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">m_plot =<span class="st"> </span><span class="kw">memoise</span>(plot_mpg)
<span class="kw">benchmark</span>(<span class="kw">m_plot</span>(<span class="dv">10</span>), <span class="kw">plot_mpg</span>(<span class="dv">10</span>), <span class="dt">columns =</span> <span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;relative&quot;</span>, <span class="st">&quot;elapsed&quot;</span>))
<span class="co">#         test relative elapsed</span>
<span class="co">#1   m_plot(10)    1.000   0.007</span>
<span class="co">#2 plot_mpg(10)  481.857   3.373</span></code></pre></div>
<p>suggests that we can obtain a 500-fold speed-up.</p>
</div>
<div id="function-closures" class="section level3">
<h3><span class="header-section-number">7.2.3</span> Function closures</h3>
<p>More advanced caching is available using <em>function closures</em>. A closure in R is an object that contains functions bound to the environment the closure was created in. Technically all functions in R have this property, but we use the term function closure to denote functions where the environment is not <code>.GlobalEnv</code>. One of the environments associated with function is known as the enclosing environment, that is, where was the function created. We can determine the enclosing environment using the <code>environment</code> function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">environment</span>(plot_mpg)</code></pre></div>
<pre><code>## &lt;environment: R_GlobalEnv&gt;</code></pre>
<p>The <code>plot_mpg</code> function’s enclosing environment is the <code>.GlobalEnv</code>. This is important for variable scope, i.e. where should be look for a particular object. Consider the function <code>f</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f =<span class="st"> </span>function() {
  x =<span class="st"> </span><span class="dv">5</span>
  function() {
    x
  }
}</code></pre></div>
<p>When we call the function <code>f</code>, the object returned is a function. While the enclosing environment of <code>f</code> is <code>.GlobalEnv</code>, the enclosing environment of the <strong>returned</strong> function is something different</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g =<span class="st"> </span><span class="kw">f</span>()
<span class="kw">environment</span>(g)</code></pre></div>
<pre><code>## &lt;environment: 0x76141d0&gt;</code></pre>
<p>When we call this new function <code>g</code>,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x =<span class="st"> </span><span class="dv">10</span>
<span class="kw">g</span>()</code></pre></div>
<pre><code>## [1] 5</code></pre>
<p>The value returned is obtained from <code>environment(g)</code> is 5, not <code>.GlobalEnv</code>. This environment allows to cache variables between function calls. The <code>counter</code> function is basic example of this feature</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">counter =<span class="st"> </span>function() {
  no =<span class="st"> </span><span class="dv">0</span>
  count =<span class="st"> </span>function() {
    no &lt;&lt;-<span class="st"> </span>no +<span class="st"> </span><span class="dv">1</span>
    no
  }
}</code></pre></div>
<p>When we call the function, we retain object values between function calls</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sc =<span class="st"> </span><span class="kw">counter</span>()
<span class="kw">sc</span>()</code></pre></div>
<pre><code>## [1] 1</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sc</span>()</code></pre></div>
<pre><code>## [1] 2</code></pre>
<p>The key points of the <code>counter</code> function are</p>
<ul>
<li><p>The counter function returns a function</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sc =<span class="st"> </span><span class="kw">counter</span>()
<span class="kw">sc</span>()</code></pre></div>
<pre><code>## [1] 1</code></pre></li>
<li>The enclosing environment of <code>sc</code> is not <code>.GlobalEnv</code> instead, it’s the binding environment of <code>sc</code>.</li>
<li>The function <code>sc</code> has an environment that can be used to store/cache values</li>
<li><p>The operator <code>&lt;&lt;-</code> is used to alter the <code>no</code>.</p></li>
</ul>
<p>We can exploit function closures to simplify our code. Suppose we wished to simulate a games of Snakes and Ladders. We could have function that checked if we landed on a Snake, and if so move</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">check_snake =<span class="st"> </span>function(square) {
   switch(<span class="kw">as.character</span>(square), 
       <span class="st">&#39;16&#39;</span>=<span class="dv">6</span>,  <span class="st">&#39;49&#39;</span>=<span class="dv">12</span>, <span class="st">&#39;47&#39;</span>=<span class="dv">26</span>, <span class="st">&#39;56&#39;</span>=<span class="dv">48</span>, <span class="st">&#39;62&#39;</span>=<span class="dv">19</span>, 
       <span class="st">&#39;64&#39;</span>=<span class="dv">60</span>, <span class="st">&#39;87&#39;</span>=<span class="dv">24</span>, <span class="st">&#39;93&#39;</span>=<span class="dv">73</span>, <span class="st">&#39;96&#39;</span>=<span class="dv">76</span>, <span class="st">&#39;98&#39;</span>=<span class="dv">78</span>, 
       square)
}</code></pre></div>
<p>If we then wanted to determine how often we landed on a Snake, we could use a function closure to keep track</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">check_snake =<span class="st"> </span>function() {
  no_of_snakes =<span class="st"> </span><span class="dv">0</span>
  function(square) {
    new_square =<span class="st"> </span>switch(<span class="kw">as.character</span>(square), 
       <span class="st">&#39;16&#39;</span>=<span class="dv">6</span>,  <span class="st">&#39;49&#39;</span>=<span class="dv">12</span>, <span class="st">&#39;47&#39;</span>=<span class="dv">26</span>, <span class="st">&#39;56&#39;</span>=<span class="dv">48</span>, <span class="st">&#39;62&#39;</span>=<span class="dv">19</span>, 
       <span class="st">&#39;64&#39;</span>=<span class="dv">60</span>, <span class="st">&#39;87&#39;</span>=<span class="dv">24</span>, <span class="st">&#39;93&#39;</span>=<span class="dv">73</span>, <span class="st">&#39;96&#39;</span>=<span class="dv">76</span>, <span class="st">&#39;98&#39;</span>=<span class="dv">78</span>, 
       square)
    no_of_snakes =<span class="st"> </span>no_of_snakes +<span class="st"> </span>(new_square !=<span class="st"> </span>square)
    new_square
  }
}</code></pre></div>
<p>By keeping the variable <code>no_of_snakes</code> attached to the <code>check_snake</code> function, enables us to have cleaner code.</p>
</div>
<div id="vectorised-code" class="section level3">
<h3><span class="header-section-number">7.2.4</span> Vectorised code</h3>
<p>When writing code in R, you need to remember that you are using R and not C (or even Fortran 77!). For example,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Change 1000 uniform random numbers
x =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1000</span>) +<span class="st"> </span><span class="dv">1</span>
logsum =<span class="st"> </span><span class="dv">0</span>
for(i in <span class="dv">1</span>:<span class="kw">length</span>(x))
  logsum =<span class="st"> </span>logsum +<span class="st"> </span><span class="kw">log</span>(x[i])</code></pre></div>
<p>is a piece R code that has a strong, unhealthy influence from C. Instead we should write</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">logsum =<span class="st"> </span><span class="kw">sum</span>(<span class="kw">log</span>(x))</code></pre></div>
<p>Writing code this way has a number of benefits.</p>
<ul>
<li>It’s faster. When <span class="math inline">\(n = 10^7\)</span> the ``R way’’ is about forty times faster.</li>
<li>It’s neater.</li>
<li>It doesn’t contain a bug when <code>x</code> is of length <span class="math inline">\(0\)</span>.</li>
</ul>
<p>Another common example is sub-setting a vector. When writing in C, we would have something like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans =<span class="st"> </span><span class="ot">NULL</span>
for(i in <span class="dv">1</span>:<span class="kw">length</span>(x)) {
  if(x[i] &lt;<span class="st"> </span><span class="dv">0</span>) 
    ans =<span class="st"> </span><span class="kw">c</span>(ans, x[i])
}</code></pre></div>
<p>This of course can be done simply with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ans =<span class="st"> </span>x[x &lt;<span class="st"> </span><span class="dv">0</span>]</code></pre></div>
<div class="figure" style="text-align: center">
<img src="_main_files/figure-html/6-2-1.png" alt="(\#fig:6-2)Example of Monte-Carlo integration. To estimate the area under the curve throw random points at the graph and count the number of points that lie under the curve."  />
<p class="caption">
(#fig:6-2)Example of Monte-Carlo integration. To estimate the area under the curve throw random points at the graph and count the number of points that lie under the curve.
</p>
</div>
<div id="example-monte-carlo-integration" class="section level4">
<h4><span class="header-section-number">7.2.4.1</span> Example: Monte-Carlo integration</h4>
<p>It’s also important to make full use of R functions that use vectors. For example, suppose we wish to estimate <span class="math display">\[
\int_0^1 x^2 dx
\]</span> using a basic Monte-Carlo method. Essentially, we throw darts at the curve and count the number of darts that fall below the curve (as in @ref(fig:6-2)).</p>
<p><em>Monte Carlo Integration</em></p>
<ol style="list-style-type: decimal">
<li>Initialise: <code>hits = 0</code></li>
<li><strong>for i in 1:N</strong></li>
<li><span class="math inline">\(~~~\)</span> Generate two random numbers, <span class="math inline">\(U_1, U_2\)</span>, between 0 and 1</li>
<li><span class="math inline">\(~~~\)</span> If <span class="math inline">\(U_2 &lt; U_1^2\)</span>, then <code>hits = hits + 1</code></li>
<li><strong>end for</strong></li>
<li>Area estimate = <code>hits/N</code></li>
</ol>
<p>A standard C approach to implementing this Monte-Carlo algorithm would be something like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N =<span class="st"> </span><span class="dv">500000</span>
f =<span class="st"> </span>function(N){
  hits =<span class="st"> </span><span class="dv">0</span>
  for(i in <span class="dv">1</span>:N)  {
    u1 =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>); u2 =<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1</span>)
    if(u1^<span class="dv">2</span> &gt;<span class="st"> </span>u2)
      hits =<span class="st"> </span>hits +<span class="st"> </span><span class="dv">1</span>
  }
  <span class="kw">return</span>(hits/N)
}</code></pre></div>
<p>In R this takes a few seconds:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(<span class="kw">f</span>(N))</code></pre></div>
<pre><code>##    user  system elapsed 
##   1.703   0.000   1.704</code></pre>
<p>In contrast, a more R-centric approach would be the following:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f1 =<span class="st"> </span>function(N){
  hits =<span class="st"> </span><span class="kw">sum</span>(<span class="kw">runif</span>(N)^<span class="dv">2</span> &gt;<span class="st"> </span><span class="kw">runif</span>(N))
  <span class="kw">return</span>(hits/N)
}</code></pre></div>
<p><code>f1</code> is around <span class="math inline">\(30\)</span> times faster than <code>f</code>, illustrating the efficiency gains that can be made by vectorising your code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">system.time</span>(<span class="kw">f1</span>(N))</code></pre></div>
<pre><code>##    user  system elapsed 
##   0.034   0.000   0.034</code></pre>
</div>
</div>
</div>
<div id="parallel-computing" class="section level2">
<h2><span class="header-section-number">7.3</span> Parallel computing</h2>
<p>In recent R versions (since R 2.14.0) ** parallel** package comes pre-installed with base R. The ** parallel** package must still be loaded before use however, and you must determine the number of available cores manually, as illustrated below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;parallel&quot;</span>)
no_of_cores =<span class="st"> </span><span class="kw">detectCores</span>()</code></pre></div>
<p>The computer used to compile the published version of this book chapter has 2 CPUs/Cores.</p>
<div id="parallel-versions-of-apply-functions" class="section level3">
<h3><span class="header-section-number">7.3.1</span> Parallel versions of apply functions</h3>
<p>The most commonly used parallel applications are parallelized replacements of <code>lapply</code>, <code>sapply</code> and <code>apply</code>. The parallel implementations and their arguments are shown below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parLapply</span>(cl, x, FUN, ...)
<span class="kw">parApply</span>(<span class="dt">cl =</span> <span class="ot">NULL</span>, X, MARGIN, FUN, ...)
<span class="kw">parSapply</span>(<span class="dt">cl =</span> <span class="ot">NULL</span>, X, FUN, ..., <span class="dt">simplify =</span> <span class="ot">TRUE</span>, <span class="dt">USE.NAMES =</span> <span class="ot">TRUE</span>) </code></pre></div>
<p>Note that each function has an argument <code>cl</code> which must be created by <code>makeCluster</code>. This function, amongst other things, specifies the number of processors to use.</p>
</div>
<div id="example-parallel-bootstraping" class="section level3">
<h3><span class="header-section-number">7.3.2</span> Example: parallel bootstraping</h3>
<p>In 1965, Gordon Moore co-founder of Intel, observed that the number of transistors in a dense integrated circuit doubles approximately every two years. This observation is known as Moore’s law. A scatter plot (figure @ref(fig:6-3)) of processors over the last thirty years shows that that this law seems to hold.</p>
<div class="figure">
<img src="_main_files/figure-html/6-3-1.png" alt="(\#fig:6-3)Transistor counts against introduction date. Credit: https://en.wikipedia.org/wiki/Transistor_count"  />
<p class="caption">
(#fig:6-3)Transistor counts against introduction date. Credit: <a href="https://en.wikipedia.org/wiki/Transistor_count" class="uri">https://en.wikipedia.org/wiki/Transistor_count</a>
</p>
</div>
<p>We can estimate the trend using simple linear regression. A standard algorithm for obtaining uncertainty estimates on regression coefficients is bootstrapping. This is a simple algorithm; at each iteration we sample with replacement from the original data set and estimate the parameters of the new data set. The distribution of the parameters gives us our uncertainty estimate. We begin by loading the data set and creating a function for performing a single bootstrap</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">data</span>(<span class="st">&quot;transistors&quot;</span>, <span class="dt">package=</span><span class="st">&quot;efficient&quot;</span>)
bs =<span class="st"> </span>function(i) {
  s =<span class="st"> </span><span class="kw">sample</span>(<span class="dv">1</span>:<span class="kw">NROW</span>(transistors), <span class="dt">replace=</span><span class="ot">TRUE</span>)
  trans_samp =<span class="st"> </span>transistors[s,]
  <span class="kw">coef</span>(<span class="kw">lm</span>(<span class="kw">log2</span>(Count) ~<span class="st"> </span>Year, <span class="dt">data=</span>trans_samp))
}</code></pre></div>
<p>We can then perform <span class="math inline">\(N=10^4\)</span> bootstraps using <code>sapply</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">N =<span class="st"> </span><span class="dv">10000</span>
<span class="kw">sapply</span>(<span class="dv">1</span>:N, bs)</code></pre></div>
<p>Rewriting this code to make use of the ** parallel** package is straightforward. We begin by making a cluster and exporting the data set</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;parallel&quot;</span>)
cl =<span class="st"> </span><span class="kw">makeCluster</span>(<span class="dv">6</span>)
<span class="kw">clusterExport</span>(cl, <span class="st">&quot;transistors&quot;</span>)</code></pre></div>
<p>Then use <code>parSapply</code> and stop the cluster</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">parSapply</span>(cl, <span class="dv">1</span>:N, bs)
<span class="kw">stopCluster</span>(cl)</code></pre></div>
<p>On this computer, we get a four-fold speed-up.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopCluster</span>(cl)</code></pre></div>
</div>
<div id="process-forking" class="section level3">
<h3><span class="header-section-number">7.3.3</span> Process forking</h3>
<p>Another way of running code in parallel is to use the <code>mclapply</code> and <code>mcmapply</code> functions. These functions use forking forking, that is creating a new copy of a process running on the CPU. However, Windows does not support this low-level functionality in the way that Linux does.</p>
</div>
</div>
<div id="the-byte-compiler" class="section level2">
<h2><span class="header-section-number">7.4</span> The byte compiler</h2>
<p>The ** compiler** package, written by R Core member Luke Tierney has been part of R since version 2.13.0. Since R 2.14.0, all of the standard functions and packages in base R are pre-compiled into byte-code. This is illustrated by the base function <code>mean</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mean</code></pre></div>
<pre><code>## function (x, ...) 
## UseMethod(&quot;mean&quot;)
## &lt;bytecode: 0x6201490&gt;
## &lt;environment: namespace:base&gt;</code></pre>
<p>The third line contains the <code>bytecode</code> of the function. This means that the <strong>compiler</strong> package has translated the R function into another language that can be interpreted by a very fast interpreter.</p>
<p>The <strong>compiler</strong> package allows R functions to be compiled, resulting in a byte code version that may run faster<a href="#fn20" class="footnoteRef" id="fnref20"><sup>20</sup></a>. The compilation process eliminates a number of costly operations the interpreter has to perform, such as variable lookup. Amazingly the compiler package is almost entirely pure R, with just a few C support routines.</p>
<div id="example-the-mean-function" class="section level3">
<h3><span class="header-section-number">7.4.1</span> Example: the mean function</h3>
<p>The <strong>compiler</strong> package comes with R, so we just need to load the package in the usual way</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(<span class="st">&quot;compiler&quot;</span>)</code></pre></div>
<p>Next we create an inefficient function for calculating the mean. This function takes in a vector, calculates the length and then updates the <code>total</code> variable.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">my_mean =<span class="st"> </span>function(x) {
  total =<span class="st"> </span><span class="dv">0</span>
  n =<span class="st"> </span><span class="kw">length</span>(x)
  for(i in <span class="dv">1</span>:n)
    total =<span class="st"> </span>total +<span class="st"> </span>x[i]/n
  total
}</code></pre></div>
<p>This is clearly a bad function and we should just <code>mean</code> function, but it’s a useful comparison. Compiling the function is straightforward</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cmp_mean =<span class="st"> </span><span class="kw">cmpfun</span>(my_mean)</code></pre></div>
<p>Then we use the <code>benchmark</code> function to compare the three variants</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## Generate some data
x =<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100</span>)
<span class="kw">benchmark</span>(<span class="kw">my_mean</span>(x), <span class="kw">cmp_mean</span>(x), <span class="kw">mean</span>(x), 
          <span class="dt">columns=</span><span class="kw">c</span>(<span class="st">&quot;test&quot;</span>, <span class="st">&quot;elapsed&quot;</span>, <span class="st">&quot;relative&quot;</span>),
          <span class="dt">order=</span><span class="st">&quot;relative&quot;</span>, <span class="dt">replications=</span><span class="dv">5000</span>)</code></pre></div>
<p>The compiled function is around seven times faster than the uncompiled function. Of course, the native <code>mean</code> function is faster, but the compiling does make a significant difference (figure @ref(fig:6-4)).</p>
<div class="figure">
<img src="_main_files/figure-html/6-4-1.png" alt="(\#fig:6-4)Comparsion of mean functions."  />
<p class="caption">
(#fig:6-4)Comparsion of mean functions.
</p>
</div>
</div>
<div id="compiling-code" class="section level3">
<h3><span class="header-section-number">7.4.2</span> Compiling code</h3>
<p>There are a number of ways to compile code. The easiest is to compile individual function using <code>cmpfun</code>, but this obviously doesn’t scale. If you create a package, then you automatically compile the package on installation by adding</p>
<pre><code>ByteCompile: true</code></pre>
<p>to the <code>DESCRIPTION</code> file. Most R packages installed using <code>install.packages</code> are not compiled. We can enable (or force) packages to be compiled by starting R with the environment variable <code>R_COMPILE_PKGS</code> set to a positive integer value.</p>
<p>A final option to use just-in-time (JIT) compilation. The <code>enableJIT</code> function disables JIT compilation if the argument is <code>0</code>. Arguments <code>1</code>, <code>2</code>, or <code>3</code> implement different levels of optimisation. JIT can also be enabled by setting the environment variable <code>R_ENABLE_JIT</code>, to one of these values.</p>
<!--chapter:end:06-programming.Rmd-->
</div>
</div>
</div>
<div id="efficient-rcpp" class="section level1">
<h1><span class="header-section-number">8</span> Efficient Rcpp</h1>
<!--chapter:end:07-rcpp.Rmd-->
</div>
<div id="efficient-memory" class="section level1">
<h1><span class="header-section-number">9</span> Efficient Memory</h1>
<!--chapter:end:08-memory.Rmd-->
</div>
<div id="efficient-learning" class="section level1">
<h1><span class="header-section-number">10</span> Efficient Learning</h1>
<!--chapter:end:09-learning.Rmd-->
<!-- There seems to be a bug with bookdown, where the last chapter doesn't include the css or 
mathjax. This is a dummy chapter.
-->
<link rel="stylesheet" type="text/css" href="style.css">
<script type="text/javascript" async
  src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
</script>
<!--chapter:end:100.Rmd-->
<div id="refs" class="references">
<div id="ref-berkun2005art">
<p>Berkun, Scott. 2005. <em>The Art of Project Management</em>. O’Reilly.</p>
</div>
<div id="ref-Braun2007">
<p>Braun, John, and Duncan J Murdoch. 2007. <em>A First Course in Statistical Programming with R</em>. Vol. 25. Cambridge University Press Cambridge.</p>
</div>
<div id="ref-Burns2011">
<p>Burns, Patrick. 2011. <em>The R Inferno</em>. Lulu.com.</p>
</div>
<div id="ref-Codd1979">
<p>Codd, E. F. 1979. “Extending the database relational model to capture more meaning.” <em>ACM Transactions on Database Systems</em> 4 (4): 397–434. doi:<a href="https://doi.org/10.1145/320107.320109">10.1145/320107.320109</a>.</p>
</div>
<div id="ref-eddelbuettel2010benchmarking">
<p>Eddelbuettel, Dirk. 2010. “Benchmarking Single-and Multi-Core BLAS Implementations and GPUs for Use with R.” Mathematica.</p>
</div>
<div id="ref-Eddelbuettel_2011">
<p>Eddelbuettel, Dirk, Romain François, J. Allaire, John Chambers, Douglas Bates, and Kevin Ushey. 2011. “Rcpp: Seamless R and C++ Integration.” <em>Journal of Statistical Software</em> 40 (8): 1–18.</p>
</div>
<div id="ref-Goldberg1991">
<p>Goldberg, David. 1991. “What Every Computer Scientist Should Know About Floating-Point Arithmetic.” <em>ACM Computing Surveys (CSUR)</em> 23 (1). ACM: 5–48.</p>
</div>
<div id="ref-grolemund_r_2016">
<p>Grolemund, Garrett, and Hadley Wickham. 2016. <em>R for Data Science</em>. 1 edition. O’Reilly Media.</p>
</div>
<div id="ref-kersten2011researcher">
<p>Kersten, Martin L, Stratos Idreos, Stefan Manegold, Erietta Liarou, and others. 2011. “The Researcher’s Guide to the Data Deluge: Querying a Scientific Database in Just a Few Seconds.” <em>PVLDB Challenges and Visions</em> 3.</p>
</div>
<div id="ref-PMBoK_2000">
<p>PMBoK, A. 2000. “Guide to the Project Management Body of Knowledge.” <em>Project Management Institute, Pennsylvania USA</em>.</p>
</div>
<div id="ref-sekhon2006art">
<p>Sekhon, Jasjeet S. 2006. “The Art of Benchmarking: Evaluating the Performance of R on Linux and OS X.” <em>The Political Methodologist</em> 14 (1): 15–19.</p>
</div>
<div id="ref-Wickham2014">
<p>Wickham, Hadley. 2014a. <em>Advanced R</em>. CRC Press.</p>
</div>
<div id="ref-Wickham_2014">
<p>———. 2014b. “Tidy Data.” <em>The Journal of Statistical Software</em> 14 (5). <a href="http://www.jstatsoft.org/v59/i10 http://vita.had.co.nz/papers/tidy-data.html" class="uri">http://www.jstatsoft.org/v59/i10 http://vita.had.co.nz/papers/tidy-data.html</a>.</p>
</div>
<div id="ref-Wickham_2015">
<p>———. 2015. <em>R Packages</em>. O’Reilly Media, Inc.</p>
</div>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Benchmarking conducted for a presentation “R on Different Platforms” at useR 2006 found that R was marginally faster on Windows than Linux set-ups. Similar results were reported in an academic paper, with R completing statistical analyses faster on a Linux than Mac OS’s <span class="citation">(Sekhon <a href="#ref-sekhon2006art">2006</a>)</span>. In 2015 <a href="http://blog.revolutionanalytics.com/2015/04/benchmarks-of-rro-on-osx-and-ubuntu.html">Revolution R</a> supported these results with slightly faster run times for certain benchmarks on Ubuntu than Mac systems. The data from the <code>benchmarkme</code> package also suggests that running code under the Linux OS is faster.<a href="#fnref1">↩</a></p></li>
<li id="fn2"><p>See <a href="http://www.jason-french.com/blog/2013/03/11/installing-r-in-linux/">jason-french.com/blog/2013/03/11/installing-r-in-linux/</a> for more information on installing R on a variety of Linux distributions.<a href="#fnref2">↩</a></p></li>
<li id="fn3"><p>In the previous section we specified only a few packages to update.<a href="#fnref3">↩</a></p></li>
<li id="fn4"><p>See <a href="https://cran.r-project.org/web/packages/httr/vignettes/api-packages.html"><code>vignette(&quot;api-packages&quot;)</code></a> from the <code>httr</code> package for more on this.<a href="#fnref4">↩</a></p></li>
<li id="fn5"><p>Other open source R IDEs exist, including <a href="https://rkward.kde.org/">RKWard</a>, <a href="http://sourceforge.net/projects/tinn-r/">Tinn-R</a> and <a href="https://www.rforge.net/JGR/">JGR</a>. <a href="https://www.gnu.org/software/emacs/">emacs</a> is another popular software environment. However, it has a very steep learning curve.<a href="#fnref5">↩</a></p></li>
<li id="fn6"><p>‘Slots’ are sub-elements of an object analogous to a column in a <code>data.frame</code> but referred to with <code>@</code> not <code>$</code>.<a href="#fnref6">↩</a></p></li>
<li id="fn7"><p>See <a href="http://www.brodrigues.co/2014/11/11/benchmarks-r-blas-atlas-rro/">brodrigues.co/2014/11/11/benchmarks-r-blas-atlas-rro/</a>, which finds Revolution R to be marginally faster than R using OpenBLAS and ATLAS BLAS implementations and <a href="http://brettklamer.com/diversions/statistical/faster-blas-in-r/">Faster BLAS in R</a>, which does not.<a href="#fnref7">↩</a></p></li>
<li id="fn8"><p>The Oxford Dictionary’s definition of workflow is similar, with a more industrial feel: “The sequence of industrial, administrative, or other processes through which a piece of work passes from initiation to completion.”<a href="#fnref8">↩</a></p></li>
<li id="fn9"><p>The importance of workflow has not gone unnoticed by the R community and there are a number of different suggestions to boost R productivity. <a href="http://robjhyndman.com/hyndsight/workflow-in-r/">Rob Hyndman</a>, for example, advocates the strategy of using four self-contained scripts to break up R work into manageable chunks: <code>load.R</code>, <code>clean.R</code>, <code>func.R</code> and <code>do.R</code>.<a href="#fnref9">↩</a></p></li>
<li id="fn10"><p>A number of programs have been developed to assist project management and planning, however. These include <a href="http://sourceforge.net/projects/projectlibre/">ProjectLibre</a> and <a href="http://sourceforge.net/projects/projectlibre/">GanttProject</a>.<a href="#fnref10">↩</a></p></li>
<li id="fn11"><p>For a more comprehensive discussion of Gantt charts in R, please refer to <a href="http://stackoverflow.com/questions/3550341/gantt-charts-with-r">stackoverflow.com/questions/3550341</a>.<a href="#fnref11">↩</a></p></li>
<li id="fn12"><p>An excellent overview of the ‘hadleyverse’ and its benefits is available from <a href="https://barryrowlingson.github.io/hadleyverse">barryrowlingson.github.io/hadleyverse</a>.<a href="#fnref12">↩</a></p></li>
<li id="fn13"><p>Since R 3.2.3 the base function <code>download.file()</code> can be used to download from secure (<code>https://</code>) connections on any operating system.<a href="#fnref13">↩</a></p></li>
<li id="fn14"><p>This is a multi-table dataset on Dutch naval expeditions used with permission from the CWI Database Architectures Group and described more fully at <a href="https://www.monetdb.org/Documentation/UserGuide/MonetDB-R">monetdb.org</a>.<a href="#fnref14">↩</a></p></li>
<li id="fn15"><p>Note that the dimensions of the data change from having 10 observations across 18 columns to 162 rows in only 3 columns. Note that when we print the object <code>rawt[1:3,]</code>, the class of each variable is given (<code>chr</code>, <code>fctr</code>, <code>int</code> refer to character, factor and integer classes, respectively). This is because <code>read_csv</code> uses the <code>tbl</code> class from the <strong>dplyr</strong> package (described below).<a href="#fnref15">↩</a></p></li>
<li id="fn16"><p>Note in this code block the variable name is surrounded by back-quotes (<code>). This allows R to refer to column names that are non-standard. Note also the syntax:</code>rename<code>takes the</code>data.frame<code>as the first object and then creates new variables by specifying</code>new_variable_name = original_name`.<a href="#fnref16">↩</a></p></li>
<li id="fn17"><p>Note that this syntax is a defining feature of <strong>dplyr</strong> and many of its functions work in the same way. Later we’ll learn how this syntax can be used alongside the <code>%&gt;%</code> ‘pipe’ command to write clear data manipulation commands.<a href="#fnref17">↩</a></p></li>
<li id="fn18"><p>Note the first argument in the function is the vector we’re aiming to aggregate and the second is the grouping variable (in this case Countries). A quirk of R is that the grouping variable must be supplied as a list. Next we’ll see a way of writing this that is neater.<a href="#fnref18">↩</a></p></li>
<li id="fn19"><p>One <a href="http://stackoverflow.com/questions/21435339">question</a> on the stackoverflow website titled ‘data.table vs dplyr’ has received much attention and sets out the advantages of each approach. The question and subsequent responses do not provide a conclusive answer to the issue and the responses may be out of date in some cases but it certainly makes for interesting reading and delves into the philosophy underlying each approach.<a href="#fnref19">↩</a></p></li>
<li id="fn20"><p>The authors have yet to find a situation where byte compiled code runs significantly slower.<a href="#fnref20">↩</a></p></li>
</ol>
</div>
<!--bookdown:body:end-->


</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

</body>
</html>
